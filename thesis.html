<div id="thesis__001-preamble.md">
<!-- % \lstlistoflistings -->
<!-- % \listoftables -->
</div>
<div id="thesis__010-intro.md">
<h1 data-number="1" id="thesis__010-intro.md__introduction"><span
class="header-section-number">1</span> Introduction</h1>
</div>
<div id="thesis__020-related-work.md">
<h1 data-number="2" id="thesis__020-related-work.md__related-work"><span
class="header-section-number">2</span> Related work</h1>
<p>In this chapter, we will examine prior works relevant to our problem
of connecting multiple parties over The Internet for a joint MPyC
computation. To identify the challenges, we will begin with an overview
of The Internet Protocol Suite, which is central to the modern Internet.
Following that, we will review several existing network overlay
solutions that we can later use as building blocks for an overall
solution to our problem. To maintain a consistent mental picture of the
solutions, we will map them to the layers of the model. While many
protocols implement aspects of several layers and do not strictly fit
inside the OSI model, it is still a useful visualization tool.</p>
<h2 data-number="2.1"
id="thesis__020-related-work.md__the-internet"><span
class="header-section-number">2.1</span> The Internet</h2>
<p>The modern Internet is a global multi-tiered network of devices that
communicate using the protocols of the Internet Protocol Suite (TCP/IP).
Typically, an manages the physical infrastructure that connects an
end-user’s devices with the rest of the internet. Figure describes the
responsibilities of the 7 layers of the OSI model and how they fit with
the protocols of the Internet Protocol Suite, which are often referred
to as the TCP/IP model. The newer TCP/IP model only recognizes 4 layers
as it merges the OSI Session (L5) and Presentation (L6) layers into the
Application layer (L7), as well as the Physical layer (L1) into the Data
link layer (L2). While the TCP/IP model is a more accurate
representation of The Internet, the 7-layer numbers of the OSI model are
still widely used in the literature.</p>
<figure>
<embed src="thesis/../figures/osi-map-tcp.drawio.pdf"
style="width:100.0%" />
<figcaption aria-hidden="true">OSI model mapping of the Internet
Protocol Suite</figcaption>
</figure>
<!-- IP -->
<p>The <strong></strong> is a Network (L3) protocol of the Internet
Protocol Suite that is responsible for delivering datagrams between
devices across the boundaries of their by possibly routing traffic via
multiple intermediate devices (routers). A datagram is a connectionless
packet that is delivered on a best-effort basis. IP datagrams have a
header that contains fields such as the <strong>IP addresses</strong> of
its source and destination, and a payload that encapsulates the data
from the protocols of the layers above. Routers are devices that are
part of multiple networks and relay datagrams between them based on a
routing table that maps IP address ranges () to networks.</p>
<p><strong></strong> and <strong></strong> are Transport (L4) protocols
that add the concept of ports to allow having multiple communication
channels simultaneously between two devices. UDP provides best-effort
delivery, while TCP is a reliable transport with delivery guarantees.
TCP maintains stateful connections and handles acknowledgments and
retransmissions in case packets are lost in transit.</p>
<p><strong></strong> is a protocol that adds encryption on top of a
reliable transport protocol such as TCP. It is usually placed in the
Presentation Layer (L6), but it does not strictly fit in any single OSI
layer. It is rather complex because it needs to support many possible
use cases across the internet. The <strong>Noise Protocol
Framework</strong> <span class="citation" data-cites="noiseDocs">(Perrin
2018)</span> is a more recent effort that applies the ideas of TLS in a
simplified way by serving as a blueprint for designing use-case specific
protocols for establishing secure communication channels based on
handshake patterns. It powers the end-to-end encryption in messaging
applications such as WhatsApp and Signal, and software such as WireGuard
and Nebula.</p>
<p>The version of the Internet Protocol that was originally deployed
globally (IPv4) uses 32-bit numbers as IP addresses, allowing for around
4 billion unique addresses. Due to the popularity of the internet, there
are many more devices than available IPv4 addresses, which has caused
challenges. IPv6 is a newer version of the protocol that uses a larger
128-bit address space which is sufficient for assigning 100 addresses
for each atom on Earth. Its adoption has been slow, as according to
Google as of 2023 only around 37% of the requests to their services use
IPv6. Additionally, despite that IPv6 allows for all devices to be
addressable on the Internet, for security reasons, most of them would
use firewalls to block incoming remote traffic that is not associated
with outgoing connections.</p>
<p>A widespread solution to the addressing problem is <strong></strong>.
It allows many devices without globally unique IP addresses to initiate
connections to publicly addressable devices on the Internet via a
limited number of gateways that must have globally unique IP addresses.
A NAT gateway replaces the local source IP address of each outgoing IP
datagram with its own public IP address before passing it on to the next
link on the way to the destination while maintaining a mapping between
the source and destination IPs in a translation table. The destination
host can then address its responses back to the NAT gateway’s public IP
address, which in turn replaces its own IP from the incoming datagrams
with the IP of the local device and relays them to it. If the IP
datagrams encapsulate TCP/UDP packets, the gateway additionally rewrites
the source and destination ports, which means that NAT techniques can be
placed somewhere between Layers 3 and 4 of the OSI model.</p>
<p>NATs have implications on connectivity that are similar to IPv6
firewalls as they allow devices on a local network to initiate
bidirectional communication to remote devices with public IP addresses,
but connections cannot be natively initiated by the remote devices. As
Figure shows, it follows that when two devices are behind separate NATs,
neither can contact the other first. <strong>Client/Server</strong>
communications are less affected by this limitation because many local
Clients can contact a Server deployed to a public IP address by its
administrators. <strong>Peer-to-Peer</strong> communications, however,
are more challenging because the peers are often devices in separate
residential networks behind different NATs. Several <strong>NAT
traversal</strong> techniques try to solve this with different
performance tradeoffs and success that varies depending on the NAT <span
class="citation"
data-cites="natBehaviorRFC">(<strong>natBehaviorRFC?</strong>)</span>
and its behaviors when mapping ports and IP addresses. </p>
<figure>
<img src="thesis/../figures/nat-intro.png" style="height:25.0%"
alt="Two parties behind separate NATs" />
<figcaption aria-hidden="true">Two parties behind separate
NATs</figcaption>
</figure>
<p>One approach that fits the Client/Server model is for the devices
behind NATs to initiate bidirectional connections to a publicly
addressable <strong>relay</strong> server that forwards the Peer-to-Peer
traffic to the appropriate recipient. Compared to direct communication,
relaying results in a higher network latency due to the longer path that
each packet must travel. Maintaining a relay server requires some
technical expertise and may be costly depending on the expected
throughput. Despite the drawbacks, relaying works under most networking
scenarios and is therefore often used as a fallback in case all other
approaches fail to find a direct path. Protocols such as
<strong></strong> <span class="citation"
data-cites="turnRFC">(<strong>turnRFC?</strong>)</span> and
<strong></strong> <span class="citation"
data-cites="derpDocs">(<strong>derpDocs?</strong>)</span> can be used to
securely implement relaying.</p>
<p>The NAT gateway in many residential networks is a Router device under
the customer’s control that has a statically or dynamically assigned
public IP address. Most routers can be manually configured through their
admin page to forward all traffic that arrives at a given port to a
specific device on the local network. Remote applications that know the
IP address of the router and the forwarded port can then contact it to
initiate a connection to the local device. The manual configuration,
however, can be inconvenient and many users may be unaware of that
setting because it is not necessary for the more familiar Client/Server
communications. Some routers also support programmatic configuration of
port forwarding via a Layer 7 protocol like <strong></strong> or its
successors <strong></strong> and <strong></strong>. Those protocols,
however, are not always supported and are often disabled by the local
network administrators due to security concerns related to bugs in their
implementation, vulnerable IOT devices or malicious programs being able
to expose local devices to the internet.</p>
<p>An efficient NAT traversal approach that works with some types of
NATs is to use <strong></strong> <span class="citation"
data-cites="stunRFC">(<strong>stunRFC?</strong>)</span> in combination
with UDP hole punching. STUN is a Client/Server protocol operating at
Layer 7 that allows applications to detect the presence of NAT gateways
on the network path to a public endpoint, to identify their types and
discover the public IP address that they map to. To achieve this, the
device uses UDP to contact a public STUN server which responds with the
source IP address and port of the incoming datagrams. If a NAT gateway
rewrote the IP address and port, then the device will know this by
comparing them to its local IP address and port. Additional STUN servers
may be contacted to check if the NAT gateway maps consistent IP
addresses and ports. UDP hole punching is a related technique that
allows two devices</p>
<p>to contact detect its own NAT type and the public address of the NAT
gateway via, which relies on the predictable port mapping algorithms
that many routers use and a public third party host that can be
contacted by the local devices and later serve as an introduction point
for them (Figure ).</p>
<blockquote>
<p> hole punching based on concepts from . The machines of each party
can contact a public server , which will note what addresses the
connections come from and inform the parties. Since the parties
initiated the connection to the STUN server, their routers will keep a
mapping between their local IP addresses and the port that was allocated
for the connection to be able to forward the incoming traffic. Those
“holes” in the NATs were originally intended for the STUN server, but
mesh VPNs use the stateless “fire and forget” UDP protocol for their
internal communication, which does not require nor provides a mechanism
for the NATs to verify who sent a UDP packet. With most NATs, this is
enough to be able to (ab)use the “punched holes” for the purpose of
traffic from other parties. Mesh VPNs implement the stateful and
protocols on top of UDP and expose a regular network interface to the
other programs, keeping them shielded from the underlying complexities.
Other NAT implementations such as Symmetric NAT and can be more
difficult to “punch through” due to their more complex port mapping
strategies. In those cases, establishing P2P connections might involve
guesswork or even fail and require falling back to routing the
(encrypted) traffic via another party or service.</p>
</blockquote>
<figure>
<img src="thesis/../figures/nat-traversal.png" style="height:25.0%"
alt="NAT traversal via STUN" />
<figcaption aria-hidden="true">NAT traversal via STUN</figcaption>
</figure>
<p>In most mobile networks (4G, 5G) the utilizes a <strong></strong> as
part of their infrastructure, while all devices under the user’s
control, including the router, only have local IP addresses. STUN
techniques would fail to discover a direct path between two parties
behind separate CGNATs or other unpredictable NAT algorithms. The only
remaining possibility is for a like <strong></strong>, where a publicly
reachable third-party host is used not only for introducing the peers
but also for relaying all (possibly encrypted) traffic between them.</p>
<ul>
<li><p>Hairpinning</p></li>
<li><p><strong></strong></p>
<ul>
<li>Layer 3 protocol suite part of the Internet Protocol Suite</li>
<li>used inside VPN software</li>
<li>has implementations in both user and kernel space as well as
hardware implementations</li>
<li>rewrites and encrypts the IP headers and payloads</li>
<li>virtual routing table</li>
<li>Initially was built into IPv6, separate from IPv4</li>
</ul></li>
</ul>
<h2 data-number="2.2"
id="thesis__020-related-work.md__network-overlays"><span
class="header-section-number">2.2</span> Network overlays</h2>
<p>Most Network Overlay solutions use a combination of the NAT traversal
techniques mentioned previously. They can be placed in Layers 2, 3 or 7.
Layer 2 overlays act as a virtual network switch, while Layer 3 overlays
act as a virtual network router. Layer 7 overlays are implemented in
user-space as libraries or applications that run on top of the network
stack of the host operating system. Layer 2 and 3 overlays can either be
implemented as kernel modules or as user-space applications that use a
<strong>TUN/TAP</strong> driver to interface with the kernel.</p>
<p>Figure shows an approximate OSI model mapping of several protocols
and network overlay solutions from the point of view of the systems that
use them and the arrows show dependency relations between them.</p>
<figure>
<embed src="thesis/../figures/osi-map-overlays.drawio.pdf"
style="height:90.0%" />
<figcaption aria-hidden="true">OSI model mapping of various protocols
</figcaption>
</figure>
<h3 data-number="2.2.1"
id="thesis__020-related-work.md__tuntap-driver"><span
class="header-section-number">2.2.1</span> TUN/TAP driver</h3>
<ul>
<li>Layer 2 vs Layer 3 Networks
<ul>
<li>Layer 2 overlays bridge networks
<ul>
<li>virtual network switch</li>
<li>remote machines are on the same virtual LAN and can share the same
IP address range</li>
<li>allows broadcast/multicast</li>
<li>TAP driver</li>
</ul></li>
<li>Layer 3 overlays route traffic between separate local networks
<ul>
<li>virtual network router</li>
<li>remote machines are on separate LANs</li>
<li>simpler to configure</li>
<li>TUN driver</li>
</ul></li>
</ul></li>
</ul>
<h3 data-number="2.2.2"
id="thesis__020-related-work.md__traditional-vpns"><span
class="header-section-number">2.2.2</span> Traditional VPNs</h3>
<p> are implemented as Layer 2 or 3 network overlays. They are commonly
used for securely connecting machines from different . They provide
software emulation of a network interface controller via a TUN/TAP
driver on the operating system level and allow other software to
transparently use the functionality of the suite without requiring extra
changes. Traditional such as IPSec <span class="citation"
data-cites="ipSecDocs">(<strong>ipSecDocs?</strong>)</span> and OpenVPN
<span class="citation" data-cites="openVPNDocs">(OpenVPN 2022)</span>
use a centralized service that all (encrypted) client communications
must pass through. This introduces a single point of failure and a
potential bottleneck that might negatively impact the performance of the
multi-party computations due to their nature.</p>
<h3 data-number="2.2.3"
id="thesis__020-related-work.md__wireguard"><span
class="header-section-number">2.2.3</span> WireGuard</h3>
<p>WireGuard <span class="citation"
data-cites="donenfeldWireGuardNextGeneration2017">(Donenfeld
2017)</span> is a more recent protocol with a design informed by lessons
learned from IPSec and OpenVPN and a key management approach inspired by
SSH. It is a lower-level protocol that focuses on configuration
simplicity while network topology, peer discovery and key distribution
are left as a responsibility of higher-level systems that use it as a
building block. Wireguard is implemented as a Layer 3 overlay over UDP
tunnels. WireGuard has both user-space implementations that use a TUN
driver and also has direct support built into the Linux Kernel since
version 5.6 (May 2020). The kernel implementation allows for better
performance because it does not need to copy packets between the kernel
and user-space memory.</p>
<p>The snippets below show a minimal set of configuration options that
need to be provided for two peers to be able to form secure tunnels with
each other.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode ini"><code class="sourceCode ini"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># peer1.conf</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[Interface]</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Address </span><span class="ot">=</span><span class="st"> 101.0.0.1/32</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">ListenPort </span><span class="ot">=</span><span class="st"> </span><span class="dv">53063</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">PrivateKey </span><span class="ot">=</span><span class="st"> ePTiXXhHjvAHdWUr8Bimk30n0gh3m241RAzsN0JZDW0=</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">[Peer]</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">PublicKey </span><span class="ot">=</span><span class="st"> BSn0ejd1Y3bKuD+Xpg0ZZeOf+Ies/oql0NZxw+SOmkc=</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">AllowedIPs </span><span class="ot">=</span><span class="st"> 101.0.0.2/32</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Endpoint </span><span class="ot">=</span><span class="st"> peer1.example.com:38133</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ini"><code class="sourceCode ini"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># peer2.conf</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[Interface]</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Address </span><span class="ot">=</span><span class="st"> 101.0.0.2/32</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">ListenPort </span><span class="ot">=</span><span class="st"> </span><span class="dv">38133</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">PrivateKey </span><span class="ot">=</span><span class="st"> sN/d6XUPEVPGSziVgCCOnOivDK+qAoYC3nxnssQ5Rls=</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">[Peer]</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="dt">PublicKey </span><span class="ot">=</span><span class="st"> e/TxvPmrgcc1G4cSH2bHv5J0PRHXKjYxTFoU8r+G93E=</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="dt">AllowedIPs </span><span class="ot">=</span><span class="st"> 101.0.0.1/32</span></span></code></pre></div>
<p>Each peer has a public/private key pair that is used for
authentication and encryption based on the Noise Protocol Framework
<span class="citation" data-cites="noiseDocs">(Perrin 2018)</span>. The
<code>Address</code> field specifies the virtual IP address that the
local network interface will use, while the <code>AllowedIPs</code>
field specifies what virtual IP addresses are associated with a peer’s
public key. A peer’s <code>Endpoint</code> field specifies the URL at
which it can be reached. Only one of the peers must be configured with a
reachable endpoint for the other one. In the above example once
<code>peer1</code> initiates communication with <code>peer2</code>,
<code>peer2</code> will learn the current endpoint of <code>peer1</code>
and will be able to communicate back with it.</p>
<h3 data-number="2.2.4"
id="thesis__020-related-work.md__mesh-vpns"><span
class="header-section-number">2.2.4</span> Mesh VPNs</h3>
<ul>
<li>Tinc</li>
<li>N2N</li>
<li>Tailscale</li>
<li>Nebula</li>
<li>ZeroTier</li>
</ul>
<p>Mesh such as Tinc <span class="citation"
data-cites="tincDocs">(Sliepen 2022)</span>, Tailscale <span
class="citation" data-cites="tailscaleDocs">(Tailscale n.d.)</span> and
Nebula <span class="citation" data-cites="nebulaDocs">(Defined
2022)</span> utilize NAT Traversal techniques to create direct links
between the clients for the data traffic. Authentication, authorization
and traffic encryption are performed using certificates based on public
key cryptography.</p>
<p>All three are open-source, except Tailscale’s coordination service
which handles peer discovery and identity management. Headscale <span
class="citation" data-cites="fontJuanfontHeadscale2022">(Font [2020]
2022)</span> is a community-driven open-source alternative for that
component. Tinc is the oldest of the three but has a relatively small
community. It is mainly developed by a single author and appears to be
more academic than industry motivated. Nebula and Tailscale are both
business driven. Tailscale was started by some high-profile ex-googlers
and is the most end-user-focused of the three, providing a service that
allows people to sign up using identity providers such as Google,
Microsoft, GitHub and others. They also provide an Admin console that
allows a user to easily add their personal devices to a network or share
them with others. It also has support for automation tools like
Terraform for creating authorization keys and managing an based
firewall. Nebula was originally developed at the instant messaging
company Slack to create overlay networks for their cross-region cloud
infrastructure, but the authors later started a new company and are
currently developing a user-centric platform similar to Tailscale’s.
Nebula is more customizable than Tailscale and since it is completely
open-source it can be adapted to different use cases, but it is also
more involved to set up. A certificate authority needs to be configured
for issuing the identities of the participating hosts. Furthermore,
publicly accessible coordination servers need to be deployed to
facilitate the host discovery. Tailscale employs a distributed relay
network of servers, while Nebula can be configured to route via one of
the other peers in the VPN.</p>
<h3 data-number="2.2.5"
id="thesis__020-related-work.md__layer-7-overlays"><span
class="header-section-number">2.2.5</span> Layer 7 overlays</h3>
<h4 data-number="2.2.5.1"
id="thesis__020-related-work.md__webrtc-is"><span
class="header-section-number">2.2.5.1</span> WebRTC is</h4>
<ul>
<li>WebRTC
<ul>
<li>Uses STUN/TURN</li>
<li>d</li>
</ul></li>
<li>OpenZiti
<ul>
<li>uses relays</li>
</ul></li>
<li>ngrok</li>
<li>TOR</li>
<li>BitTorrent</li>
<li>IPFS</li>
<li>Ethereum</li>
<li>Teleport</li>
<li>Freenet</li>
</ul>
</div>
<div id="thesis__030-methods.md">
<h1 data-number="3"
id="thesis__030-methods.md__testing-methodology"><span
class="header-section-number">3</span> Testing methodology</h1>
<p>In the following chapters, we will design and implement several
solutions for ad hoc MPC sessions based on a subset of the previously
discussed related works:</p>
<ul>
<li>Internet protocol</li>
<li>Wireguard</li>
<li>Tailscale</li>
<li>Headscale</li>
<li>? Headscale with DID identity?</li>
<li>? WebRTC?</li>
<li>A custom solution that automates the WireGuard configuration by
visiting a web page</li>
</ul>
<p>Additionally, we will analyze and compare them in terms of
performance, security and usability</p>
<h2 data-number="3.1"
id="thesis__030-methods.md__measuring-performance"><span
class="header-section-number">3.1</span> Measuring performance</h2>
<p>During the preparation phase of the project, we developed the
framework which simplifies and automates the process of deploying
machines in different geographical regions, connecting them via an
overlay network and executing multiparty computations between them,
where each machine represents a different party.</p>
<p>To summarize, is a set of scripts that use several automation
tools:</p>
<ul>
<li>Terraform - declarative provisioning</li>
<li>NixOS - declarative Linux distribution</li>
<li>Colmena - declarative deployment for NixOS</li>
<li>PSSH - parallel execution of remote scripts over ssh</li>
<li>DigitalOcean - a cloud provider</li>
</ul>
<p>It allows us to quickly provision cloud virtual machines in multiple
regions and reproducibly deploy all necessary software for running a
multiparty computation over a chosen network overlay solution. The
source code of can be found on <a
href="https://github.com/e-nikolov/mpyc">GitHub</a></p>
<p>Each solution will be deployed using the framework and the
performance will be quantitatively measured in terms of the time it
takes to execute several MPyC demos. The selected demos have different
complexities in terms of communication rounds and message sizes which
will allow us to observe their impact on the overall performance.</p>
<ol type="1">
<li>Secret Santa - high round complexity with small messages</li>
<li>Convolutional Neural Network (CNN) MNIST classifier - low round
complexity with large messages</li>
</ol>
<p>The demos will be configured at three different input size levels</p>
<ul>
<li>Low,</li>
<li>Medium</li>
<li>High</li>
</ul>
<p>Furthermore, the demos will be executed in several networking
scenarios:</p>
<ol type="1">
<li>1-10 parties in the same geographic region</li>
<li>1-10 parties evenly distributed across two nearby regions</li>
<li>1-10 parties evenly distributed across two distant regions</li>
<li>1-10 parties distributed across multiple distant regions</li>
</ol>
<h2 data-number="3.2" id="thesis__030-methods.md__security"><span
class="header-section-number">3.2</span> Security</h2>
<p>We will analyze aspects such as</p>
<ul>
<li>key distribution</li>
<li>trust model - are there any trusted third parties and what would be
the consequences if they are corrupted or breached</li>
<li>traffic encryption</li>
<li>identity strength</li>
</ul>
<h2 data-number="3.3" id="thesis__030-methods.md__usability"><span
class="header-section-number">3.3</span> Usability</h2>
<p>For each solution, we will describe the steps that the parties need
to perform to execute a joint multiparty computation. Those steps will
be analyzed in terms of:</p>
<ul>
<li>Complexity - how much technical expertise is expected from the
parties to be able to execute the steps</li>
<li>Initial effort - how much effort is each party expected to put in
preparing for their first joint computation</li>
<li>Repeated effort - after the initial setup, how much effort is
required to perform another computation
<ul>
<li>with the same set of parties</li>
<li>with another set of parties</li>
</ul></li>
<li>Finalization effort - how much effort is required to finalize the
MPC session once it is complete and clean up any left-over artifacts or
resources so that the machine of each party is in its original
state</li>
</ul>
</div>
<div id="thesis__050-internet-protocol.md">
<h1 data-number="4"
id="thesis__050-internet-protocol.md__internet-protocol-based-solution"><span
class="header-section-number">4</span> Internet Protocol based
solution</h1>
<p>This solution focuses on directly using the internet protocol without
involving an overlay network. Our goal is to analyze the implications of
using only the functionalities that MPyC directly supports to serve as
the reference for our later experiments.</p>
<h2 data-number="4.1"
id="thesis__050-internet-protocol.md__implementation-details"><span
class="header-section-number">4.1</span> Implementation details</h2>
<p>We will manually set up the multiparty computations via the public IP
addresses of the machines and DNS.</p>
<h2 data-number="4.2"
id="thesis__050-internet-protocol.md__performance-analysis"><span
class="header-section-number">4.2</span> Performance analysis</h2>
<h2 data-number="4.3"
id="thesis__050-internet-protocol.md__security-analysis"><span
class="header-section-number">4.3</span> Security analysis</h2>
<h2 data-number="4.4"
id="thesis__050-internet-protocol.md__usability-analysis"><span
class="header-section-number">4.4</span> Usability analysis</h2>
</div>
<div id="thesis__060-wireguard.md">
<h1 data-number="5"
id="thesis__060-wireguard.md__wireguard-based-solution"><span
class="header-section-number">5</span> WireGuard based solution</h1>
<p>This solution creates an overlay network by manually configuring
WireGuard on each machine.</p>
<h2 data-number="5.1"
id="thesis__060-wireguard.md__implementation-details"><span
class="header-section-number">5.1</span> Implementation details</h2>
<h2 data-number="5.2"
id="thesis__060-wireguard.md__performance-analysis"><span
class="header-section-number">5.2</span> Performance analysis</h2>
<h2 data-number="5.3"
id="thesis__060-wireguard.md__security-analysis"><span
class="header-section-number">5.3</span> Security analysis</h2>
<h2 data-number="5.4"
id="thesis__060-wireguard.md__usability-analysis"><span
class="header-section-number">5.4</span> Usability analysis</h2>
</div>
<div id="thesis__070-tailscale.md">
<h1 data-number="6"
id="thesis__070-tailscale.md__tailscale-based-solution"><span
class="header-section-number">6</span> Tailscale based solution</h1>
<p>Tailscale is a VPN solution that configures a mesh of direct
Wireguard tunnels between the peers.</p>
<h2 data-number="6.1"
id="thesis__070-tailscale.md__implementation-details"><span
class="header-section-number">6.1</span> Implementation details</h2>
<h2 data-number="6.2"
id="thesis__070-tailscale.md__performance-analysis"><span
class="header-section-number">6.2</span> Performance analysis</h2>
<h2 data-number="6.3"
id="thesis__070-tailscale.md__security-analysis"><span
class="header-section-number">6.3</span> Security analysis</h2>
<h3 data-number="6.3.1" id="thesis__070-tailscale.md__trust-model"><span
class="header-section-number">6.3.1</span> Trust model</h3>
<p>There is a centralized service that deals with the key distribution,
which needs to be trusted to provide the correct public keys for the
correct parties</p>
<h3 data-number="6.3.2" id="thesis__070-tailscale.md__identity"><span
class="header-section-number">6.3.2</span> Identity</h3>
<p>Identity is based on third party identity providers such as Microsoft
and GitHub</p>
<ul>
<li>Magic DNS</li>
<li><h2 id="thesis__070-tailscale.md__usability-analysis">Usability
analysis</h2></li>
</ul>
<p>With tailscale each party needs to</p>
<ul>
<li>register a Tailscale account</li>
<li>Download and install tailscale on the machine they want to run a
multiparty computation</li>
<li>Run tailscale on their machine and logs into their account in order
to link it to their own Tailnet</li>
<li>Share their Tailscale machine with the Tailnets of each of the other
parties</li>
<li>Download the demo they want to run</li>
<li>Form the flags for running the chosen demo
<ul>
<li>add -P $HOST:$PORT for each party using their Tailscale
hostname/virtual IP</li>
</ul></li>
<li>Run the demo</li>
</ul>
</div>
<div id="thesis__080-headscale.md">
<h1 data-number="7"
id="thesis__080-headscale.md__headscale-based-solution"><span
class="header-section-number">7</span> Headscale based solution</h1>
<p>This solution is similar to the Tailscale one, but it uses Headscale
- a self-hosted open-source alternative to the closed-source Tailscale
coordination service.</p>
<h2 data-number="7.1"
id="thesis__080-headscale.md__implementation-details"><span
class="header-section-number">7.1</span> Implementation details</h2>
<h2 data-number="7.2"
id="thesis__080-headscale.md__performance-analysis"><span
class="header-section-number">7.2</span> Performance analysis</h2>
<h2 data-number="7.3"
id="thesis__080-headscale.md__security-analysis"><span
class="header-section-number">7.3</span> Security analysis</h2>
<h3 data-number="7.3.1" id="thesis__080-headscale.md__trust-model"><span
class="header-section-number">7.3.1</span> Trust model</h3>
<p>There still is a centralized service like in the Tailscale solution,
but here it is self-deployed.</p>
<h3 data-number="7.3.2" id="thesis__080-headscale.md__identity"><span
class="header-section-number">7.3.2</span> Identity</h3>
<h2 data-number="7.4"
id="thesis__080-headscale.md__usability-analysis"><span
class="header-section-number">7.4</span> Usability analysis</h2>
</div>
<div id="refs" class="references csl-bib-body hanging-indent"
role="list">
<div id="ref-nebulaDocs" class="csl-entry" role="listitem">
Defined. 2022. <span>“Nebula: <span>Open Source Overlay
Networking</span> | <span>Nebula Docs</span>.”</span> 2022. <a
href="https://docs.defined.net/docs/">https://docs.defined.net/docs/</a>.
</div>
<div id="ref-donenfeldWireGuardNextGeneration2017" class="csl-entry"
role="listitem">
Donenfeld, Jason A. 2017. <span>“<span>WireGuard</span>: <span>Next
Generation Kernel Network Tunnel</span>.”</span> In <em>Proceedings 2017
<span>Network</span> and <span>Distributed System Security
Symposium</span></em>. <span>San Diego, CA</span>: <span>Internet
Society</span>. <a
href="https://doi.org/10.14722/ndss.2017.23160">https://doi.org/10.14722/ndss.2017.23160</a>.
</div>
<div id="ref-fontJuanfontHeadscale2022" class="csl-entry"
role="listitem">
Font, Juan. (2020) 2022. <span>“Juanfont/Headscale.”</span> <a
href="https://github.com/juanfont/headscale">https://github.com/juanfont/headscale</a>.
</div>
<div id="ref-openVPNDocs" class="csl-entry" role="listitem">
OpenVPN. 2022. <span>“Community <span>Resources</span>.”</span>
<span>OpenVPN</span>. 2022. <a
href="https://openvpn.net/community-resources/">https://openvpn.net/community-resources/</a>.
</div>
<div id="ref-noiseDocs" class="csl-entry" role="listitem">
Perrin, Trevor. 2018. <span>“The <span>Noise Protocol
Framework</span>,”</span> July.
</div>
<div id="ref-tincDocs" class="csl-entry" role="listitem">
Sliepen, Guus. 2022. <span>“Tinc <span>Docs</span>.”</span> November 30,
2022. <a
href="https://www.tinc-vpn.org/docs/">https://www.tinc-vpn.org/docs/</a>.
</div>
<div id="ref-tailscaleDocs" class="csl-entry" role="listitem">
Tailscale. n.d. <span>“Tailscale.”</span> <span>Tailscale</span>.
Accessed November 30, 2022. <a
href="https://tailscale.com/kb/">https://tailscale.com/kb/</a>.
</div>
</div>

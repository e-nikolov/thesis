<!-- % \lstlistoflistings -->
<!-- % \listoftables -->
<h2 data-number="0.1" id="introduction"><span
class="header-section-number">0.1</span> Introduction</h2>
<h1 data-number="1"
id="the-state-of-multiparty-communications-over-the-internet"><span
class="header-section-number">1</span> The State of Multiparty
Communications over the Internet</h1>
<!-- This chapter aims to provide a brief overview of prior work related to multiparty connectivity over the Internet and their suitability for joint MPyC computations.  on the fundamentals of Internet communications, highlighting the challenges faced in communications between multiple independent parties. Additionally,  a systematic overview of the available solutions. -->
<p>This chapter provides background information on the challenges of
Internet communications between multiple independent parties. It also
presents a systematic overview of the available solutions, using the
reference model as a conceptual framework. Section 1.1 briefly explores
the fundamentals of the Internet, its protocols, the limitations for
peer-to-peer protocols, and some of the approaches to overcome them.
Section 1.2 discusses higher-level overlay networks that build on top of
the lower-level protocols from section 1.1.</p>
<!-- The presented solutions will be mapped to the layers of the \gls{osi} model. While many protocols implement aspects of several layers and do not strictly fit inside the OSI model, it is still a useful tool for comparing them. -->
<h2 data-number="1.1" id="sec:internet"><span
class="header-section-number">1.1</span> Internet Fundamentals</h2>
<p>The Internet is a global network that consists of numerous
interconnected computer networks spanning billions of host devices owned
by diverse parties from around the world. Key components of the Internet
include the Internet Protocol Suite (known as TCP/IP) and the physical
infrastructure that connects the individual networks. Sections of the
infrastructure are deployed and managed by different tiers of who also
maintain links between each other. To ensure efficient utilization of
the hardware, the Internet relies on packet-switching techniques that
divide the data traffic into smaller individually processed packets.</p>
<!-- that are handled individually by the network infrastructure. The individual packets can be retransmitted in case of errors and may be routed via different paths to their destination before being reassembled there to restore the original data. Packet switching allows for more efficient use of the underlying hardware and better reliability. -->
<!-- The Internet Protocol Suite utilizes packet-switching, meaning that application layer communications are broken into smaller discrete packets that are handled individually by the network infrastructure. A protocol typically has a \gls{pdu} that describes the information that  c has a header  i  A packet contains multiple nested a header and a payload, where the header identifies the protocol that  that  which protocol which protocols are involvedhierarchically organized information from the protocols.   identifies  information that identifies its from the various communication protocols with each protocol having its own \gls{pdu}. 
The various protocols have their own \glspl{pdu} that have a header that ide  -->
<p>Communication protocols are usually organized into abstraction layers
based on the scope of their functionality. Several reference models
define different layering schemes. The OSI model recognizes 7 layers,
while TCP/IP itself combines some of the layers and recognizes 4. Figure
shows how the two models relate to each other and describes the
responsibilities of the various layers. Throughout this thesis, we will
refer to the 7 layer numbers of the OSI model as they are more widely
used in the literature.</p>
<p>Services that are implemented as Application layer (L7) protocols on
top of TCP/IP include the , file transfer (FTP), email (SMTP), instant
messaging, remote access (SSH<span class="citation"
data-cites="sshRFC">(Lonvick and Ylonen 2006)</span>) and others. The
Web is a collection of interconnected documents that use Web
technologies such as HTML and JavaScript. It is typically accessed via a
user-agent software such as a <strong><em>Web Browser</em></strong>.</p>
<!-- 
The \gls{www} or simply the Web is a collection of interconnected documents, e.g. HTML Web Pages, available on the Internet and is typically accessed via a user-agent software such as a ***Web Browser***. The term "the Web" is sometimes used interchangeably with the Internet, but the Internet supports other services as well, e.g. file transfer (FTP), email (SMTP), instant messaging, remote access (SSH) and others. -->
<!-- Conceptual frameworks like the \gls{osi} model are useful for understanding the objectives and functions of communication protocols. Figure \ref{osi-map-tcp} describes the responsibilities of the 7 layers of the OSI model and how they relate to the TCP/IP model used by the Internet Protocol Suite. The newer TCP/IP model only recognizes 4 layers as it merges the OSI Session (L5) and Presentation (L6) layers into the Application layer (L7), as well as the Physical layer (L1) into the Data link layer (L2). While the TCP/IP model is a more accurate representation of the Internet, the 7-layer numbers of the OSI model are still widely used in the literature.  -->
<!-- 
The Internet is a global multi-tiered computer network of billions of host devices that communicate using the protocols of the Internet Protocol Suite (TCP/IP). \glspl{isp} are responsible for managing different sections of the infrastructure that connects the \glspl{lan} of various end-users including households and enterprises.  -->
<figure>
<embed src="thesis/../figures/osi-map-tcp.drawio.pdf"
style="width:100.0%" />
<figcaption aria-hidden="true">OSI model mapping of the Internet
Protocol Suite</figcaption>
</figure>
<p>The following sub-sections will briefly cover the main protocols of
the Internet Protocol Suite, the issues with multiparty communications
and some of the low-level mitigation techniques.</p>
<!-- IP -->
<h3 data-number="1.1.1" id="communication-protocols"><span
class="header-section-number">1.1.1</span> Communication Protocols</h3>
<p>The <strong></strong> <span class="citation"
data-cites="ipv4RFC">(<span>“Internet <span>Protocol</span>”</span>
1981)</span> is a Network layer (L3) protocol of the Internet Protocol
Suite that is responsible for transferring datagrams between devices
across the boundaries of their by possibly routing them via multiple
intermediate devices (e.g. routers). A datagram is a self-contained unit
of data, typically associated with connectionless protocols that provide
no guarantees for delivery or ordering (e.g. IP, UDP). . IP datagrams
have a header that contains fields such as the <strong>IP
addresses</strong> of its source and destination, and a payload that
encapsulates the data from the Transport Layer (L4) protocols. A
<strong><em>router</em></strong> is a device that is part of multiple
networks and relays datagrams between them based on a routing table that
maps IP address ranges to networks.</p>
<p><strong><em></em></strong> is a very thin Transport layer (L4)
protocol that only provides port multiplexing and checksumming on top of
IP.
<!-- **\acrfull{udp}** [@udpRFC] and **\acrfull{tcp}** [@tcpRFC] are Transport layer (L4) protocols. -->
- Port multiplexing - uses 16-bit numbers to allow multiple processes
behind the same IP address to establish their own communication channels
- Checksumming - used to detect errors in the datagram header and
payload</p>
<p>As with IP, UDP packets are referred to as datagrams because they are
not delivered reliably and if such features are required, they must be
implemented by the consumer of the protocol.</p>
<p><strong><em></em></strong> is another Transport layer (L4) protocol.
Like UDP, it provides port multiplexing and checksumming, but it offers
stronger delivery guarantees. Some of the features it offers are listed
below:</p>
<ul>
<li>Connection management - TCP establishes reliable connections between
the communicating hosts and can gracefully terminate them when
required</li>
<li>Segmentation - TCP splits variable-length data streams into segments
that fit inside IP datagrams and transmits them individually</li>
<li>ordering - segments have sequence numbers to ensure that they are
reassembled in the correct order at the receiving host</li>
<li>Error detection and correction - TCP retransmits a segment if its
checksum fails</li>
</ul>
<p>Both TCP and UDP are useful in different scenarios. UDP is faster and
is used for applications that can tolerate packet loss, e.g. video
streaming, VoIP, or in cases where it is preferable for an application
to implement its own reliable delivery. TCP has a higher overhead than
UDP but its reliable delivery is a good default for most applications on
the Internet.</p>
<!-- 
\todo{IP multiplexing via ports, TCP segments and segmentation, UDP no segmentation } employ 16-bit port numbers to enable multiple processes on the same host to establish their own communication channels while sharing an IP address. UDP offers faster communication, but only provides best-effort delivery, while TCP is a reliable transport protocol with stronger delivery guarantees at the expense of higher network latency. TCP maintains stateful connections that handle error detection and correction, packet ordering, flow control, acknowledgments and retransmissions in case packets are lost during transmission. -->
<p><strong><em></em></strong> is an Application layer (L7) protocol that
enables interactions on the Web between web servers and clients
(e.g. browsers). Traditionally, HTTP offers stateless request/response ,
but can also . Similar to other L7 protocols, it uses
<strong><em></em></strong> for locating resources using the format
<code>scheme://host:port/path?query=value#fragment</code>,
e.g. http://www.example.com:80/path/to/file.html. It is built on top of
TCP and provides several features such as:</p>
<ul>
<li>Request Methods - used by the client to specify the action to
perform on the resource behind the given URL, e.g. GET, POST, PUT,
DELETE, etc.</li>
<li>Headers - used to provide additional information about a request or
response, e.g. Content-Type, Authorization, Cache-Control</li>
<li>Status codes - used to indicate the result of a request, e.g. if it
was successful (200), or if the resource is missing (404)</li>
<li>Cookies - used to include stateful information about the user kept
on the client-side</li>
<li>Caching - used to specify that the result of a request can be cached
for a certain time to avoid repeating the request’s action.</li>
</ul>
<p>The <strong><em></em></strong> operates at the Application Layer (L7)
and allows the conversion of human-readable domains to IP addresses,
e.g. <code>google.com</code> to <code>142.250.179.142</code>.</p>
<h3 data-number="1.1.2" id="secure-communication-protocols"><span
class="header-section-number">1.1.2</span> Secure Communication
Protocols</h3>
<p><strong></strong> <span class="citation"
data-cites="tlsRFC">(Rescorla 2018)</span> and its precursor provide
secure communications to Application Layer (L7) protocols. TLS must be
implemented on top of a reliable transport protocol like TCP; is a
related protocol that works with connectionless protocols like UDP. TLS
does not strictly fit in any single OSI layer but it is usually placed
somewhere between the Transport Layer (L4) and the Presentation Layer
(L6). It is rather complex because it needs to support many possible use
cases while remaining backward compatible. The <strong>Noise Protocol
Framework</strong> <span class="citation" data-cites="noiseDocs">(Perrin
2018)</span> is a more recent effort that applies the ideas of TLS in a
simplified way by serving as a blueprint for designing use-case specific
protocols for establishing secure communication channels based on
handshake patterns. It powers the end-to-end encryption in messaging
applications such as WhatsApp and Signal, and software such as WireGuard
and Nebula.</p>
<p><strong><em>HTTPS</em></strong> <span class="citation"
data-cites="httpsRFC">(Rescorla 2000)</span> is a variant of that
provides encryption by working on top of TLS-secured TCP
connections.</p>
<p><strong></strong> is a protocol suite for encrypting the IP datagrams
between two hosts. It was originally developed as part of IPv6 but can
also be used with IPv4. IPSec is similar in purpose to TLS but operates
at the Network Layer (L3).</p>
<ul>
<li><strong></strong>
<ul>
<li>Layer 3 protocol suite part of the Internet Protocol Suite</li>
<li>used inside VPN software</li>
<li>has implementations in both user and kernel space as well as
hardware implementations</li>
<li>rewrites and encrypts the IP headers and payloads</li>
<li>virtual routing table</li>
<li>Initially was built into IPv6, separate from IPv4</li>
</ul></li>
</ul>
<h3 data-number="1.1.3"
id="multiparty-communication-challenges-and-mitigations"><span
class="header-section-number">1.1.3</span> Multiparty Communication
Challenges and Mitigations</h3>
<p>The version of the Internet Protocol, that was originally deployed
globally (IPv4), uses 32-bit numbers as IP addresses, allowing for
around 4 billion unique addresses. Due to the popularity of the
Internet, there are many more devices than available IPv4 addresses,
which has caused challenges. IPv6 is a newer version of the protocol
that uses a larger 128-bit address space which is sufficient for
assigning 100 addresses for each atom on Earth. However, its adoption
has been slow, as according to Google<span class="citation"
data-cites="IPv6Google">(<span>“<span>IPv6</span> –
<span>Google</span>”</span> n.d.)</span> as of 2023 around 41% of their
users access their services over IPv6. Additionally, despite that IPv6
allows for all devices to be addressable on the Internet, for security
reasons, most of them would use firewalls to block incoming remote
traffic that is not associated with outgoing connections.</p>
<p>A widespread solution to the addressing problem is <strong></strong>.
It allows many devices without globally unique IP addresses to initiate
connections to publicly addressable devices on the Internet via a
limited number of gateways that must have globally unique IP addresses.
A NAT gateway replaces the local source IP address of each outgoing IP
datagram with its own public IP address before passing it on to the next
link on the way to the destination while maintaining a mapping between
the source and destination IPs in a translation table. The destination
host can then address its responses back to the NAT gateway’s public IP
address, which in turn replaces its own IP from the incoming datagrams
with the IP of the local device and forwards them to it. If the IP
datagrams encapsulate TCP/UDP packets, the gateway additionally rewrites
the source and destination ports, which means that NAT techniques can be
placed somewhere between Layers 3 and 4 of the OSI model.</p>
<p>The effect of NAT on connectivity is similar to an IPv6 firewall as
they both allow devices on a local network to initiate bidirectional
communication to remote devices with public IP addresses, but
connections cannot be natively initiated by the remote devices. As
Figure shows, it follows that when two devices are behind separate NATs,
neither can contact the other first. <strong>Client/Server</strong>
communication is less affected by this limitation because Servers are
usually deployed to a public IP address that can be contacted by Clients
with local IP addresses. <strong>Peer-to-Peer</strong> communication,
however, is more challenging because the peers are often devices in
separate residential networks behind different NATs. Several <strong>NAT
traversal</strong> techniques try to solve this with different
performance tradeoffs and success that varies depending on the NAT <span
class="citation" data-cites="natBehaviorRFC">(Jennings and Audet
2007)</span> and its behavior when mapping ports and IP addresses. </p>
<figure>
<img src="thesis/../figures/nat-intro.png" style="height:25.0%"
alt="Two parties behind separate NATs" />
<figcaption aria-hidden="true">Two parties behind separate
NATs</figcaption>
</figure>
<p>One approach based on the Client/Server model is to use a publicly
addressable <strong>relay</strong> server that is contacted by the NATed
devices and then forwards the Peer-to-Peer traffic to the intended
recipient. Compared to direct communication, relaying results in a
higher network latency due to the longer path that each packet must
travel. Maintaining a relay server requires some technical expertise and
may be costly depending on the expected throughput. Despite the
drawbacks, relaying works under most networking scenarios and is
therefore often used as a fallback in case all other approaches fail to
find a direct path. Protocols such as <strong></strong> <span
class="citation" data-cites="turnRFC">(Reddy.K et al. 2020)</span> and
<strong></strong> <span class="citation"
data-cites="derpDocs">(<strong>derpDocs?</strong>)</span> can be used to
securely implement relaying.</p>
<p>The NAT gateway in many residential networks is a Router device under
the customer’s control that has a statically or dynamically assigned
public IP address. Most routers can be manually configured through their
admin page to forward all traffic that arrives at a given port to a
specific device on the local network. Remote applications can then
initiate a connection to the local device if they know the IP address of
the router and the forwarded port. The manual configuration, however,
can be inconvenient and many users may be unaware of that setting
because it is not necessary for the more straightforward Client/Server
communications. Some routers also support programmatic configuration of
port forwarding via a Layer 7 protocol like <strong></strong> or its
successors <strong></strong> and <strong></strong>. However, these
protocols are not always supported and are often disabled by the local
network administrators due to security concerns related to bugs in their
implementation, vulnerable IOT devices on the local network or malicious
programs being able to expose local devices to the internet.</p>
<p>An efficient NAT traversal approach that works with some types of
NATs is to use <strong></strong> <span class="citation"
data-cites="stunRFC">(Petit-Huguenin et al. 2020)</span> in combination
with UDP hole punching (Figure ). STUN is a protocol operating at Layer
7 that allows a client application to detect the presence of NAT
gateways on the network path to a public STUN server, and identify their
types and the public IP address that they map to externally. An
application sends UDP datagrams to the STUN server and it responds with
the source IP address and port specified inside the datagrams. The
application can compare its own endpoint with the source endpoint
observed by the STUN server and if the values differ, it can be inferred
that they were rewritten by a NAT. Additional STUN servers are contacted
to determine if the NAT maps IPs and ports in a predictable fashion. UDP
hole punching is a related technique that, depending on the NAT types,
can allow direct communication between two applications behind separate
NATs. The applications must discover each other’s externally mapped
endpoints, perhaps via the STUN server. If the NATs use the same
external port regardless of the remote destination, the two applications
can simultaneously send UDP packets to each other’s external endpoints.
Their respective NATs will see the outgoing connection to the other peer
- the “punched hole” - when the incoming traffic arrives from it and
forward it correctly. NATs that map different ports per remote
destination sometimes allocate port numbers predictably, which can be
used by the peers to try to guess the port that will be opened by the
opposing side’s NAT.</p>
<figure>
<img src="thesis/../figures/nat-traversal.png" style="height:25.0%"
alt="NAT traversal via STUN" />
<figcaption aria-hidden="true">NAT traversal via STUN</figcaption>
</figure>
<p>In mobile networks like 4G and 5G, the often utilizes a
<strong></strong> as part of their infrastructure, while all devices
under the user’s control, including the router, only have local IP
addresses. STUN techniques would fail to discover a direct path between
two parties behind separate CGNATs or other unpredictable NAT
algorithms. The only remaining possibility is to relay the traffic via a
publicly reachable third-party host using a protocol similar to TURN.
</p>
<p><strong><em></em></strong> is a protocol that describes a standard
way for peers to gather candidate addresses for direct communication via
STUN and TURN and then exchange them via a signaling server. The
protocol continuously checks which candidates provide the best
connection and adjusts them.</p>
<p><strong><em></em></strong> is a framework that allows peer-to-peer
communications between Web applications in Web browsers. Web
applications are normally limited to HTTP connections and cannot use raw
UDP or TCP connections. WebRTC implements the ICE functionality in Web
browsers and provides an API to Web applications.</p>
<h2 data-number="1.2" id="sec:overlays"><span
class="header-section-number">1.2</span> Overlay Networks</h2>
<p>An <strong><em>overlay network</em></strong> is a higher-order
solution that provides additional networking functionality on top of an
existing underlay network like the Internet. From the point of view of
its consumers, an overlay network may appear at a lower OSI layer,
despite being implemented using protocols from higher layers. For
example can provide virtual interfaces to the Operating System at the
Link layer (L2) or Network layer (L3) while being implemented on top of
a Transport layer (L4) protocol like or a Presentation layer (L6)
protocol like . Virtual IP addresses can be assigned to the hosts and
their applications that are already designed to work via TCP/IP can
directly use the virtual network interfaces via the regular TCP/IP
mechanisms provided by the operating system.</p>
<p>Other overlay networks are both implemented and used at the
Application layer (L2). To communicate via such an overlay network,
applications often have to implement specific functionality in their
software by utilizing a framework or a library.</p>
<ul>
<li>the low-level solutions from the previous section are complex to set
up.</li>
<li>overlay networks package some of those solutions for a specific use
case Most overlay networks use a combination of the NAT traversal
techniques mentioned previously. They can be placed in Layers 2, 3 or 7.
Layer 2 overlays act as a virtual network switch, while Layer 3 overlays
act as a virtual network router. Layer 7 overlays are implemented in
user-space as libraries or applications that run on top of the network
stack of the host operating system. Layer 2 and 3 overlays can either be
implemented as kernel modules or as user-space applications that use a
<strong>TUN/TAP</strong> driver to interface with the kernel.</li>
</ul>
<p>Figure shows an approximate OSI model mapping of several protocols
and network overlay solutions from the point of view of the systems that
use them and the arrows show dependency relations between them.</p>
<figure>
<embed src="thesis/../figures/osi-map-overlays.drawio.pdf"
style="height:90.0%" />
<figcaption aria-hidden="true">OSI model mapping of various protocols
</figcaption>
</figure>
<h3 data-number="1.2.1" id="tuntap-driver"><span
class="header-section-number">1.2.1</span> TUN/TAP driver</h3>
<ul>
<li>Layer 2 vs Layer 3 Networks
<ul>
<li>Layer 2 overlays bridge networks
<ul>
<li>virtual network switch</li>
<li>remote machines are on the same virtual LAN and can share the same
IP address range</li>
<li>allows broadcast/multicast</li>
<li>TAP driver</li>
</ul></li>
<li>Layer 3 overlays route traffic between separate local networks
<ul>
<li>virtual network router</li>
<li>remote machines are on separate LANs</li>
<li>simpler to configure</li>
<li>TUN driver</li>
</ul></li>
</ul></li>
</ul>
<h3 data-number="1.2.2" id="traditional-vpns"><span
class="header-section-number">1.2.2</span> Traditional VPNs</h3>
<ul>
<li>The term “VPN” is somewhat overloaded as it can refer to different
related concepts.</li>
</ul>
<p> are implemented as Layer 2 or 3 network overlays. They are commonly
used for securely connecting machines from different . They provide
software emulation of a network interface controller via a TUN/TAP
driver on the operating system level and allow other software to
transparently use the functionality of the suite without requiring extra
changes. Traditional such as IPSec <span class="citation"
data-cites="ipSecDocs">(<strong>ipSecDocs?</strong>)</span> and OpenVPN
<span class="citation" data-cites="openVPNDocs">(OpenVPN 2022)</span>
use a centralized service that all (encrypted) client communications
must pass through. This introduces a single point of failure and a
potential bottleneck that might negatively impact the performance of the
multiparty computations due to their nature.</p>
<h3 data-number="1.2.3" id="wireguard"><span
class="header-section-number">1.2.3</span> WireGuard</h3>
<p>WireGuard <span class="citation"
data-cites="donenfeldWireGuardNextGeneration2017">(Donenfeld
2017)</span> is a more recent protocol with a design informed by lessons
learned from IPSec and OpenVPN and a key management approach inspired by
SSH. It is a lower-level protocol that focuses on configuration
simplicity while network topology, peer discovery and key distribution
are left as a responsibility of higher-level systems that use it as a
building block. Wireguard is implemented as a Layer 3 overlay over UDP
tunnels. WireGuard has both user-space implementations that use a TUN
driver and also has direct support built into the Linux Kernel since
version 5.6 (May 2020). The kernel implementation allows for better
performance because it does not need to copy packets between the kernel
and user-space memory.</p>
<p>The snippets below show a minimal set of configuration options that
need to be provided for two peers to be able to form secure tunnels with
each other.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode ini"><code class="sourceCode ini"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># peer1.conf</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[Interface]</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Address </span><span class="ot">=</span><span class="st"> 101.0.0.1/32</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">ListenPort </span><span class="ot">=</span><span class="st"> </span><span class="dv">53063</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">PrivateKey </span><span class="ot">=</span><span class="st"> ePTiXXhHjvAHdWUr8Bimk30n0gh3m241RAzsN0JZDW0=</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">[Peer]</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">PublicKey </span><span class="ot">=</span><span class="st"> BSn0ejd1Y3bKuD+Xpg0ZZeOf+Ies/oql0NZxw+SOmkc=</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">AllowedIPs </span><span class="ot">=</span><span class="st"> 101.0.0.2/32</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Endpoint </span><span class="ot">=</span><span class="st"> peer1.example.com:38133</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ini"><code class="sourceCode ini"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># peer2.conf</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[Interface]</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Address </span><span class="ot">=</span><span class="st"> 101.0.0.2/32</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">ListenPort </span><span class="ot">=</span><span class="st"> </span><span class="dv">38133</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">PrivateKey </span><span class="ot">=</span><span class="st"> sN/d6XUPEVPGSziVgCCOnOivDK+qAoYC3nxnssQ5Rls=</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">[Peer]</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="dt">PublicKey </span><span class="ot">=</span><span class="st"> e/TxvPmrgcc1G4cSH2bHv5J0PRHXKjYxTFoU8r+G93E=</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="dt">AllowedIPs </span><span class="ot">=</span><span class="st"> 101.0.0.1/32</span></span></code></pre></div>
<p>Each peer has a public/private key pair that is used for
authentication and encryption based on the Noise Protocol Framework
<span class="citation" data-cites="noiseDocs">(Perrin 2018)</span>. The
<code>Address</code> field specifies the virtual IP address that the
local network interface will use, while the <code>AllowedIPs</code>
field specifies what virtual IP addresses are associated with a peer’s
public key. A peer’s <code>Endpoint</code> field specifies the URL at
which it can be reached. Only one of the peers must be configured with a
reachable endpoint for the other one. In the above example once
<code>peer1</code> initiates communication with <code>peer2</code>,
<code>peer2</code> will learn the current endpoint of <code>peer1</code>
and will be able to communicate back with it.</p>
<h3 data-number="1.2.4" id="mesh-vpns"><span
class="header-section-number">1.2.4</span> Mesh VPNs</h3>
<ul>
<li>Tinc</li>
<li>N2N</li>
<li>Tailscale</li>
<li>Nebula</li>
<li>ZeroTier</li>
</ul>
<p>Mesh such as Tinc <span class="citation"
data-cites="tincDocs">(Sliepen 2022)</span>, Tailscale <span
class="citation" data-cites="tailscaleDocs">(Tailscale n.d.)</span> and
Nebula <span class="citation" data-cites="nebulaDocs">(Defined
2022)</span> utilize NAT Traversal techniques to create direct links
between the clients for the data traffic. Authentication, authorization
and traffic encryption are performed using certificates based on public
key cryptography.</p>
<p>All three are open-source, except Tailscale’s coordination service
which handles peer discovery and identity management. Headscale <span
class="citation" data-cites="fontJuanfontHeadscale2022">(Font [2020]
2022)</span> is a community-driven open-source alternative for that
component. Tinc is the oldest of the three but has a relatively small
community. It is mainly developed by a single author and appears to be
more academic than industry motivated. Nebula and Tailscale are both
business driven. Tailscale was started by some high-profile ex-googlers
and is the most end-user-focused of the three, providing a service that
allows people to sign up using identity providers such as Google,
Microsoft, GitHub and others. They also provide an Admin console that
allows a user to easily add their personal devices to a network or share
them with others. It also has support for automation tools like
Terraform for creating authorization keys and managing an based
firewall. Nebula was originally developed at the instant messaging
company Slack to create overlay networks for their cross-region cloud
infrastructure, but the authors later started a new company and are
currently developing a user-centric platform similar to Tailscale’s.
Nebula is more customizable than Tailscale and since it is completely
open-source it can be adapted to different use cases, but it is also
more involved to set up. A certificate authority needs to be configured
for issuing the identities of the participating hosts. Furthermore,
publicly accessible coordination servers need to be deployed to
facilitate the host discovery. Tailscale employs a distributed relay
network of servers, while Nebula can be configured to route via one of
the other peers in the VPN.</p>
<h3 data-number="1.2.5" id="layer-7-overlays"><span
class="header-section-number">1.2.5</span> Layer 7 overlays</h3>
<h4 data-number="1.2.5.1" id="webrtc-is"><span
class="header-section-number">1.2.5.1</span> WebRTC is</h4>
<ul>
<li>WebRTC
<ul>
<li>Uses STUN/TURN</li>
</ul></li>
<li>OpenZiti
<ul>
<li>uses relays</li>
</ul></li>
<li>libP2P</li>
<li>ngrok</li>
<li>TOR</li>
<li>BitTorrent</li>
<li>IPFS</li>
<li>Ethereum</li>
<li>Teleport</li>
<li>Freenet</li>
</ul>
<h1 data-number="2" id="proof-of-concepts-and-evaluation"><span
class="header-section-number">2</span> Proof of Concepts and
Evaluation</h1>
<h2 data-number="2.1" id="testing-methodology"><span
class="header-section-number">2.1</span> Testing methodology</h2>
<p>In the following chapters, we will design and implement several
solutions for ad hoc MPC sessions based on a subset of the previously
discussed related works:</p>
<ul>
<li>Internet protocol</li>
<li>Wireguard</li>
<li>Tailscale</li>
<li>Headscale</li>
<li>? Headscale with DID identity?</li>
<li>? WebRTC?</li>
<li>A custom solution that automates the WireGuard configuration by
visiting a web page</li>
</ul>
<p>Additionally, we will analyze and compare them in terms of
performance, security and usability</p>
<h3 data-number="2.1.1" id="measuring-performance"><span
class="header-section-number">2.1.1</span> Measuring performance</h3>
<p>During the preparation phase of the project, we developed the
framework which simplifies and automates the process of deploying
machines in different geographical regions, connecting them via an
overlay network and executing multiparty computations between them,
where each machine represents a different party.</p>
<p>To summarize, is a set of scripts that use several automation
tools:</p>
<ul>
<li>Terraform - declarative provisioning</li>
<li>NixOS - declarative Linux distribution</li>
<li>Colmena - declarative deployment for NixOS</li>
<li>PSSH - parallel execution of remote scripts over ssh</li>
<li>DigitalOcean - a cloud provider</li>
</ul>
<p>It allows us to quickly provision cloud virtual machines in multiple
regions and reproducibly deploy all necessary software for running a
multiparty computation over a chosen network overlay solution. The
source code of can be found on <a
href="https://github.com/e-nikolov/mpyc">GitHub</a></p>
<p>Each solution will be deployed using the framework and the
performance will be quantitatively measured in terms of the time it
takes to execute several MPyC demos. The selected demos have different
complexities in terms of communication rounds and message sizes which
will allow us to observe their impact on the overall performance.</p>
<ol type="1">
<li>Secret Santa - high round complexity with small messages</li>
<li>Convolutional Neural Network (CNN) MNIST classifier - low round
complexity with large messages</li>
</ol>
<p>The demos will be configured at three different input size levels</p>
<ul>
<li>Low,</li>
<li>Medium</li>
<li>High</li>
</ul>
<p>Furthermore, the demos will be executed in several networking
scenarios:</p>
<ol type="1">
<li>1-10 parties in the same geographic region</li>
<li>1-10 parties evenly distributed across two nearby regions</li>
<li>1-10 parties evenly distributed across two distant regions</li>
<li>1-10 parties distributed across multiple distant regions</li>
</ol>
<h3 data-number="2.1.2" id="security"><span
class="header-section-number">2.1.2</span> Security</h3>
<p>We will analyze aspects such as</p>
<ul>
<li>key distribution</li>
<li>trust model - are there any trusted third parties and what would be
the consequences if they are corrupted or breached</li>
<li>traffic encryption</li>
<li>identity strength</li>
</ul>
<h3 data-number="2.1.3" id="usability"><span
class="header-section-number">2.1.3</span> Usability</h3>
<p>For each solution, we will describe the steps that the parties need
to perform to execute a joint multiparty computation. Those steps will
be analyzed in terms of:</p>
<ul>
<li>Complexity - how much technical expertise is expected from the
parties to be able to execute the steps</li>
<li>Initial effort - how much effort is each party expected to put in
preparing for their first joint computation</li>
<li>Repeated effort - after the initial setup, how much effort is
required to perform another computation
<ul>
<li>with the same set of parties</li>
<li>with another set of parties</li>
</ul></li>
<li>Finalization effort - how much effort is required to finalize the
MPC session once it is complete and clean up any left-over artifacts or
resources so that the machine of each party is in its original
state</li>
</ul>
<h2 data-number="2.2" id="internet-protocol-based-solution"><span
class="header-section-number">2.2</span> Internet Protocol based
solution</h2>
<p>This solution focuses on directly using the internet protocol without
involving an overlay network. Our goal is to analyze the implications of
using only the functionalities that MPyC directly supports to serve as
the reference for our later experiments.</p>
<h3 data-number="2.2.1" id="implementation-details"><span
class="header-section-number">2.2.1</span> Implementation details</h3>
<p>We will manually set up the multiparty computations via the public IP
addresses of the machines and DNS.</p>
<h3 data-number="2.2.2" id="performance-analysis"><span
class="header-section-number">2.2.2</span> Performance analysis</h3>
<h3 data-number="2.2.3" id="security-analysis"><span
class="header-section-number">2.2.3</span> Security analysis</h3>
<h3 data-number="2.2.4" id="usability-analysis"><span
class="header-section-number">2.2.4</span> Usability analysis</h3>
<h2 data-number="2.3" id="wireguard-based-solution"><span
class="header-section-number">2.3</span> WireGuard based solution</h2>
<p>This solution creates an overlay network by manually configuring
WireGuard on each machine.</p>
<h3 data-number="2.3.1" id="implementation-details"><span
class="header-section-number">2.3.1</span> Implementation details</h3>
<h3 data-number="2.3.2" id="performance-analysis"><span
class="header-section-number">2.3.2</span> Performance analysis</h3>
<h3 data-number="2.3.3" id="security-analysis"><span
class="header-section-number">2.3.3</span> Security analysis</h3>
<h3 data-number="2.3.4" id="usability-analysis"><span
class="header-section-number">2.3.4</span> Usability analysis</h3>
<h2 data-number="2.4" id="tailscale-based-solution"><span
class="header-section-number">2.4</span> Tailscale based solution</h2>
<p>Tailscale is a VPN solution that configures a mesh of direct
Wireguard tunnels between the peers.</p>
<h3 data-number="2.4.1" id="implementation-details"><span
class="header-section-number">2.4.1</span> Implementation details</h3>
<h3 data-number="2.4.2" id="performance-analysis"><span
class="header-section-number">2.4.2</span> Performance analysis</h3>
<h3 data-number="2.4.3" id="security-analysis"><span
class="header-section-number">2.4.3</span> Security analysis</h3>
<h4 data-number="2.4.3.1" id="trust-model"><span
class="header-section-number">2.4.3.1</span> Trust model</h4>
<p>There is a centralized service that deals with the key distribution,
which needs to be trusted to provide the correct public keys for the
correct parties</p>
<h4 data-number="2.4.3.2" id="identity"><span
class="header-section-number">2.4.3.2</span> Identity</h4>
<p>Identity is based on third party identity providers such as Microsoft
and GitHub</p>
<ul>
<li>Magic DNS</li>
<li><h3 id="usability-analysis">Usability analysis</h3></li>
</ul>
<p>With tailscale each party needs to</p>
<ul>
<li>register a Tailscale account</li>
<li>Download and install tailscale on the machine they want to run a
multiparty computation</li>
<li>Run tailscale on their machine and logs into their account in order
to link it to their own Tailnet</li>
<li>Share their Tailscale machine with the Tailnets of each of the other
parties</li>
<li>Download the demo they want to run</li>
<li>Form the flags for running the chosen demo
<ul>
<li>add -P $HOST:$PORT for each party using their Tailscale
hostname/virtual IP</li>
</ul></li>
<li>Run the demo</li>
</ul>
<h2 data-number="2.5" id="headscale-based-solution"><span
class="header-section-number">2.5</span> Headscale based solution</h2>
<p>This solution is similar to the Tailscale one, but it uses Headscale
- a self-hosted open-source alternative to the closed-source Tailscale
coordination service.</p>
<h3 data-number="2.5.1" id="implementation-details"><span
class="header-section-number">2.5.1</span> Implementation details</h3>
<h3 data-number="2.5.2" id="performance-analysis"><span
class="header-section-number">2.5.2</span> Performance analysis</h3>
<h3 data-number="2.5.3" id="security-analysis"><span
class="header-section-number">2.5.3</span> Security analysis</h3>
<h4 data-number="2.5.3.1" id="trust-model"><span
class="header-section-number">2.5.3.1</span> Trust model</h4>
<p>There still is a centralized service like in the Tailscale solution,
but here it is self-deployed.</p>
<h4 data-number="2.5.3.2" id="identity"><span
class="header-section-number">2.5.3.2</span> Identity</h4>
<h3 class="unnumbered" id="usability-analysis">Usability analysis</h3>
<div id="refs" class="references csl-bib-body hanging-indent"
role="doc-bibliography">
<div id="ref-nebulaDocs" class="csl-entry" role="doc-biblioentry">
Defined. 2022. <span>“Nebula: <span>Open Source Overlay
Networking</span> | <span>Nebula Docs</span>.”</span> 2022. <a
href="https://docs.defined.net/docs/">https://docs.defined.net/docs/</a>.
</div>
<div id="ref-donenfeldWireGuardNextGeneration2017" class="csl-entry"
role="doc-biblioentry">
Donenfeld, Jason A. 2017. <span>“<span>WireGuard</span>: <span>Next
Generation Kernel Network Tunnel</span>.”</span> In <em>Proceedings 2017
<span>Network</span> and <span>Distributed System Security
Symposium</span></em>. <span>San Diego, CA</span>: <span>Internet
Society</span>. <a
href="https://doi.org/10.14722/ndss.2017.23160">https://doi.org/10.14722/ndss.2017.23160</a>.
</div>
<div id="ref-fontJuanfontHeadscale2022" class="csl-entry"
role="doc-biblioentry">
Font, Juan. (2020) 2022. <em>Juanfont/Headscale</em>. <a
href="https://github.com/juanfont/headscale">https://github.com/juanfont/headscale</a>.
</div>
<div id="ref-ipv4RFC" class="csl-entry" role="doc-biblioentry">
<span>“Internet <span>Protocol</span>.”</span> 1981. Request for
Comments RFC 791. <span>Internet Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC0791">https://doi.org/10.17487/RFC0791</a>.
</div>
<div id="ref-IPv6Google" class="csl-entry" role="doc-biblioentry">
<span>“<span>IPv6</span> – <span>Google</span>.”</span> n.d. Accessed
May 21, 2023. <a
href="https://www.google.com/intl/en/ipv6/statistics.html">https://www.google.com/intl/en/ipv6/statistics.html</a>.
</div>
<div id="ref-natBehaviorRFC" class="csl-entry" role="doc-biblioentry">
Jennings, Cullen Fluffy, and Francois Audet. 2007. <span>“Network
<span>Address Translation</span> (<span>NAT</span>) <span>Behavioral
Requirements</span> for <span>Unicast UDP</span>.”</span> Request for
Comments RFC 4787. <span>Internet Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC4787">https://doi.org/10.17487/RFC4787</a>.
</div>
<div id="ref-sshRFC" class="csl-entry" role="doc-biblioentry">
Lonvick, Chris M., and Tatu Ylonen. 2006. <span>“The <span>Secure
Shell</span> (<span>SSH</span>) <span>Protocol
Architecture</span>.”</span> Request for Comments RFC 4251.
<span>Internet Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC4251">https://doi.org/10.17487/RFC4251</a>.
</div>
<div id="ref-openVPNDocs" class="csl-entry" role="doc-biblioentry">
OpenVPN. 2022. <span>“Community <span>Resources</span>.”</span>
<span>OpenVPN</span>. 2022. <a
href="https://openvpn.net/community-resources/">https://openvpn.net/community-resources/</a>.
</div>
<div id="ref-noiseDocs" class="csl-entry" role="doc-biblioentry">
Perrin, Trevor. 2018. <span>“The <span>Noise Protocol
Framework</span>,”</span> July.
</div>
<div id="ref-stunRFC" class="csl-entry" role="doc-biblioentry">
Petit-Huguenin, Marc, Gonzalo Salgueiro, Jonathan Rosenberg, Dan Wing,
Rohan Mahy, and Philip Matthews. 2020. <span>“Session <span>Traversal
Utilities</span> for <span>NAT</span> (<span>STUN</span>).”</span>
Request for Comments RFC 8489. <span>Internet Engineering Task
Force</span>. <a
href="https://doi.org/10.17487/RFC8489">https://doi.org/10.17487/RFC8489</a>.
</div>
<div id="ref-turnRFC" class="csl-entry" role="doc-biblioentry">
Reddy.K, Tirumaleswar, Alan Johnston, Philip Matthews, and Jonathan
Rosenberg. 2020. <span>“Traversal <span>Using Relays</span> Around
<span>NAT</span> (<span>TURN</span>): <span>Relay Extensions</span> to
<span>Session Traversal Utilities</span> for <span>NAT</span>
(<span>STUN</span>).”</span> Request for Comments RFC 8656.
<span>Internet Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC8656">https://doi.org/10.17487/RFC8656</a>.
</div>
<div id="ref-httpsRFC" class="csl-entry" role="doc-biblioentry">
Rescorla, Eric. 2000. <span>“<span>HTTP Over TLS</span>.”</span> Request
for Comments RFC 2818. <span>Internet Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC2818">https://doi.org/10.17487/RFC2818</a>.
</div>
<div id="ref-tlsRFC" class="csl-entry" role="doc-biblioentry">
———. 2018. <span>“The <span>Transport Layer Security</span>
(<span>TLS</span>) <span>Protocol Version</span> 1.3.”</span> Request
for Comments RFC 8446. <span>Internet Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC8446">https://doi.org/10.17487/RFC8446</a>.
</div>
<div id="ref-tincDocs" class="csl-entry" role="doc-biblioentry">
Sliepen, Guus. 2022. <span>“Tinc <span>Docs</span>.”</span> November 30,
2022. <a
href="https://www.tinc-vpn.org/docs/">https://www.tinc-vpn.org/docs/</a>.
</div>
<div id="ref-tailscaleDocs" class="csl-entry" role="doc-biblioentry">
Tailscale. n.d. <span>“Tailscale.”</span> <span>Tailscale</span>.
Accessed November 30, 2022. <a
href="https://tailscale.com/kb/">https://tailscale.com/kb/</a>.
</div>
</div>

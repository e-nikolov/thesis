<!-- \printglossary[type=\acronymtype,title=Glossary] -->
<h1 data-number="1"><span class="header-section-number">1</span> List of
Figures</h1>
<div class="list list-of-fig">

</div>
<!-- % \lstlistoflistings -->
<!-- % \listoftables -->
<h2 data-number="1.1" id="introduction"><span
class="header-section-number">1.1</span> Introduction</h2>
<h1 data-number="2"
id="the-state-of-multiparty-communications-over-the-internet"><span
class="header-section-number">2</span> The State of Multiparty
Communications over the Internet</h1>
<!-- This chapter aims to provide a brief overview of prior work related to multiparty connectivity over the Internet and their suitability for joint MPyC computations.  on the fundamentals of Internet communications, highlighting the challenges faced in communications between multiple independent parties. Additionally,  a systematic overview of the available solutions. -->
<p>This chapter provides background information on the challenges of
Internet communications between multiple independent parties. It also
presents a systematic overview of the available solutions, using the
reference model as a conceptual framework. Section 1.1 briefly explores
the fundamentals of the Internet, its protocols, the limitations for
peer-to-peer protocols, and some of the approaches to overcome them.
Section 1.2 discusses higher-level overlay networks that build on top of
the lower-level protocols from section 1.1.</p>
<!-- The presented solutions will be mapped to the layers of the \gls{osi} model. While many protocols implement aspects of several layers and do not strictly fit inside the OSI model, it is still a useful tool for comparing them. -->
<h2 data-number="2.1" id="sec:internet"><span
class="header-section-number">2.1</span> Internet Communications</h2>
<p>The Internet is a global network that consists of numerous
interconnected computer networks spanning billions of host devices owned
by diverse parties from around the world. Key components of the Internet
include the Internet Protocol Suite (known as TCP/IP) and the physical
infrastructure that connects the individual networks. Sections of the
infrastructure are deployed and managed by different tiers of who also
maintain links between each other. To ensure efficient utilization of
the hardware, the Internet relies on packet-switching techniques that
divide the data traffic into smaller individually processed packets.</p>
<!-- that are handled individually by the network infrastructure. The individual packets can be retransmitted in case of errors and may be routed via different paths to their destination before being reassembled there to restore the original data. Packet switching allows for more efficient use of the underlying hardware and better reliability. -->
<!-- The Internet Protocol Suite utilizes packet-switching, meaning that application layer communications are broken into smaller discrete packets that are handled individually by the network infrastructure. A protocol typically has a \gls{pdu} that describes the information that  c has a header  i  A packet contains multiple nested a header and a payload, where the header identifies the protocol that  that  which protocol which protocols are involvedhierarchically organized information from the protocols.   identifies  information that identifies its from the various communication protocols with each protocol having its own \gls{pdu}. 
The various protocols have their own \glspl{pdu} that have a header that ide  -->
<figure>
<embed src="thesis/../figures/osi-map-tcp.drawio.pdf"
style="width:100.0%" />
<figcaption aria-hidden="true">OSI model mapping of the Internet
Protocol Suite</figcaption>
</figure>
<p>Communication protocols are usually organized into abstraction layers
based on the scope of their functionality. Several reference models
define different layering schemes, for example, the OSI model recognizes
7 layers, while TCP/IP itself combines some of the layers and recognizes
4. Figure shows how the two models relate to each other and describes
the responsibilities of the various layers. Throughout this thesis, we
will refer to the 7 layer numbers of the OSI model as they are more
widely used in the literature.</p>
<p>Each communication protocol has its own that</p>
<p>Services that are implemented as Application layer (L7) protocols on
top of TCP/IP include the , file transfer (), email (), instant
messaging, remote access ( <span class="citation"
data-cites="sshRFC">(Lonvick and Ylonen 2006)</span>) and others. The
Web is a collection of interconnected documents that use Web
technologies such as and JavaScript. It is typically accessed via a
user-agent software such as a <strong>Web Browser</strong>.</p>
<!-- 
The \gls{www} or simply the Web is a collection of interconnected documents, e.g. HTML Web Pages, available on the Internet and is typically accessed via a user-agent software such as a **Web Browser**. The term "the Web" is sometimes used interchangeably with the Internet, but the Internet supports other services as well, e.g. file transfer (FTP), email (SMTP), instant messaging, remote access (SSH) and others. -->
<!-- Conceptual frameworks like the \gls{osi} model are useful for understanding the objectives and functions of communication protocols. Figure \ref{osi-map-tcp} describes the responsibilities of the 7 layers of the OSI model and how they relate to the TCP/IP model used by the Internet Protocol Suite. The newer TCP/IP model only recognizes 4 layers as it merges the OSI Session (L5) and Presentation (L6) layers into the Application layer (L7), as well as the Physical layer (L1) into the Data link layer (L2). While the TCP/IP model is a more accurate representation of the Internet, the 7-layer numbers of the OSI model are still widely used in the literature.  -->
<!-- 
The Internet is a global multi-tiered computer network of billions of host devices that communicate using the protocols of the Internet Protocol Suite (TCP/IP). \glspl{isp} are responsible for managing different sections of the infrastructure that connects the \glspl{lan} of various end-users including households and enterprises.  -->
<p>The following sub-sections will briefly cover the main protocols of
the Internet Protocol Suite, the issues for multiparty communications
and some of the low-level mitigation techniques.</p>
<!-- IP -->
<h3 data-number="2.1.1" id="communication-protocols"><span
class="header-section-number">2.1.1</span> Communication Protocols</h3>
<h4 data-number="2.1.1.1" id="network-layer-l3-communication"><span
class="header-section-number">2.1.1.1</span> Network Layer (L3)
Communication</h4>
<p>The <span class="citation" data-cites="ipv4RFC">(<span>“Internet
<span>Protocol</span>”</span> 1981)</span> is a Network layer (L3)
protocol of the Internet Protocol Suite that is responsible for
transferring datagrams between devices across the boundaries of their by
possibly routing them via multiple intermediate devices (e.g. routers).
A datagram is a self-contained unit of data, typically associated with
connectionless protocols that provide no guarantees for delivery or
ordering (e.g. IP, UDP). IP datagrams have a header that contains fields
such as the <strong>IP addresses</strong> of its source and destination,
and a payload that encapsulates the data from the Transport Layer (L4)
protocols. A <strong>router</strong> is a device that is part of
multiple networks and relays datagrams between them based on a routing
table that maps IP address ranges to networks.</p>
<h4 data-number="2.1.1.2" id="transport-layer-l4-communication"><span
class="header-section-number">2.1.1.2</span> Transport Layer (L4)
Communication</h4>
<p> is a very thin Transport layer (L4) protocol that only provides port
multiplexing and checksumming on top of IP.
<!-- \glsxtrfull{udp} [@udpRFC] and \glsxtrfull{tcp} [@tcpRFC] are Transport layer (L4) protocols. -->
- Port multiplexing - uses 16-bit numbers to allow multiple processes
behind the same IP address to establish their own communication channels
- Checksumming - used to detect errors in the datagram header and
payload</p>
<p>As with IP, UDP packets are referred to as datagrams because they are
not delivered reliably and if such features are required, they must be
implemented by the consumer of the protocol.</p>
<p> is another Transport layer (L4) protocol. Like UDP, it provides port
multiplexing and checksumming, but it offers stronger delivery
guarantees. Some of the features it offers are listed below:</p>
<ul>
<li>Connection management - TCP establishes reliable connections between
the communicating hosts and can gracefully terminate them when
required</li>
<li>Segmentation - TCP splits variable-length data streams into segments
that fit inside IP datagrams and transmits them individually</li>
<li>ordering - segments have sequence numbers to ensure that they are
reassembled in the correct order at the receiving host</li>
<li>Error detection and correction - TCP retransmits a segment if its
checksum fails</li>
</ul>
<p>Both TCP and UDP are useful in different scenarios. UDP is faster and
is used for applications that can tolerate packet loss, e.g. video
streaming, VoIP, or in cases where it is preferable for an application
to implement its own reliable delivery. TCP has a higher overhead than
UDP but its reliable delivery is a good default for most applications on
the Internet.</p>
<p> is a more recent Transport layer (L4) protocol that is built on top
of UDP and offers similar features to TCP, but with lower latency in
some scenarios. It provides an additional level of multiplexing within a
process, which allows multiple streams of data to be sent over the same
connection asynchronously. To better optimize the establishment of
secure connections, QUIC is tightly coupled with version 1.3. One of the
main uses of QUIC is inside version 3.</p>
<!-- \todo{
- QUIC - UDP-based protocol that provides reliable delivery, multiplexing, flow control, congestion control, and security


} -->
<!-- 
\todo{IP multiplexing via ports, TCP segments and segmentation, UDP no segmentation } employ 16-bit port numbers to enable multiple processes on the same host to establish their own communication channels while sharing an IP address. UDP offers faster communication, but only provides best-effort delivery, while TCP is a reliable transport protocol with stronger delivery guarantees at the expense of higher network latency. TCP maintains stateful connections that handle error detection and correction, packet ordering, flow control, acknowledgments and retransmissions in case packets are lost during transmission. -->
<h4 data-number="2.1.1.3" id="application-layer-l7-communication"><span
class="header-section-number">2.1.1.3</span> Application Layer (L7)
Communication</h4>
<p> is an Application layer (L7) protocol that enables stateless
request/response interactions on the Web between web servers and clients
(e.g. browsers). Similar to other L7 protocols, it uses for locating
resources using the format
<code>scheme://host:port/path?query=value#fragment</code>,
e.g. <code>http://www.example.com:80/path/to/file.html</code>. HTTP up
to version 2 uses TCP as a transport protocol and since version 3 uses .
HTTP provides several features such as:</p>
<ul>
<li>Request Methods - used by the client to specify the action to
perform on the resource behind the given URL, e.g. GET, POST, PUT,
DELETE, etc.</li>
<li>Headers - used to provide additional information about a request or
response, e.g. Content-Type, Authorization, Cache-Control</li>
<li>Status codes - used to indicate the result of a request, e.g. if it
was successful (200), or if the resource is missing (404)</li>
<li>Cookies - used to include stateful information about the user kept
on the client-side</li>
<li>Caching - used to specify that the result of a request can be cached
for a certain time to avoid repeating the request’s action.</li>
</ul>
<p>The operates at the Application Layer (L7) and allows the conversion
of human-readable domains to IP addresses, e.g. <code>google.com</code>
to <code>142.250.179.142</code>.</p>
<h3 data-number="2.1.2" id="secure-communication-protocols"><span
class="header-section-number">2.1.2</span> Secure Communication
Protocols</h3>
<h4 data-number="2.1.2.1"
id="transport-layer-l4-to-application-layer-l7-security"><span
class="header-section-number">2.1.2.1</span> Transport Layer (L4) to
Application Layer (L7) Security</h4>
<p> <span class="citation" data-cites="tlsRFC">(Rescorla 2018)</span>
and its precursor are protocols that provide secure communications to
Application layer (L7) protocols on top of a reliable Transport layer
(L4) protocol like . is a related protocol that works with
connectionless transport protocols like UDP. TLS is usually placed
somewhere between the Presentation layer (L6) and the Transport layer
(L4) because Application layer (L7) protocols use it as a transport
protocol while having to manage the TLS connections.</p>
<p>TLS relies on digital certificates and to establish trust between the
communicating parties and to prevent man-in-the-middle attacks. A
certificate includes information such as:</p>
<ul>
<li>Subject - an identifiable name for the certificate’s owner.
Depending on the use case it can be a domain name, an IP address, an
email address or others.</li>
<li>Subject’s public key - an asymmetric public key that is used by
other parties to verify that they are communicating with the subject who
is expected to be in control of the corresponding private key. The
public key can also be used to encrypt messages that only the subject
can decrypt.</li>
<li>Issuer - an entity that is responsible for validating the identity
of the subject. It is usually a that is trusted by the consumer of the
certificate, but in the case of a self-signed certificate, it can be the
subject itself</li>
<li>Issuer’s signature - a signature of the certificate’s contents using
the issuer’s private key</li>
</ul>
<p>Trusted CAs that serve as the root of trust are usually included in
the operating system or a Web browser. This allows applications to
verify the certificates of the servers they communicate with. Web
browsers use <span class="citation" data-cites="httpsRFC">(Rescorla
2000)</span> - a variant of that uses TLS to secure the underlying or
connections of Web applications. The one-way approach where only the
server has to authenticate itself to the clients is usually sufficient
for most web interactions. TLS can also be used for mutual
authentication, where both of the communicating parties have to present
a valid certificate to each other, but this requires additional
infrastructure to manage the client-side certificates. This mode of
operations is sometimes used in Zero Trust networking, in microservice
architectures and TLS-based applications.</p>
<p>TLS is rather complex because it needs to support many possible use
cases while remaining backward compatible. It allows the negotiation of
security parameters like cipher suits.</p>
<p>TLS operates at the Transport layer (L4) and above so it encrypts the
application traffic, but not the IP datagrams. While an or an intruder
with access to the network cannot decrypt the traffic to see what is
being communicated, it could see which IP addresses are communicating
with each other.</p>
<!-- 
owneA party's identity can be verified via certificates that include a public key and  can prove its identity  that wishes to authenticate itself to another party presents a public key certificate, signed by a trusted **certificate authority**. The certificate authority is responsible for verifying the identity of the party and signing the certificate. The party that receives the certificate can verify its authenticity by checking the signature against the certificate authority's public key. The certificate authority's public key is usually included in the operating system or the browser. The certificate authority is also responsible for revoking certificates that are no longer valid. The following list contains some of the features that TLS provides: -->
<!-- despite it needing another Transport to work on top of. Application layer (L7) protocols use TLS as if it were a Transport layer protocol, despite it needing    does not strictly fit in any single OSI layer but it is usually placed somewhere between the Transport Layer (L4) and the Presentation Layer (L6) -->
<!-- \todo{tls certificates} \todo{protects against man in the middle} \todo{an intruder can't see the encrypted traffic, but can see the IP addresses of the servers that are being contacted} -->
<!-- 
\todo{talk about https} -->
<h4 data-number="2.1.2.2"
id="network-layer-l3-and-data-link-layer-l2-security-protocols"><span
class="header-section-number">2.1.2.2</span> Network Layer (L3) and Data
Link Layer (L2) Security Protocols</h4>
<h5 data-number="2.1.2.2.1" id="ipsec"><span
class="header-section-number">2.1.2.2.1</span> IPSec</h5>
<p> is a protocol suite that provides secure communications at the
Network layer (L3). Unlike , mutual authentication is always required in
IPSec. This can be achieved either via digital certificates, or others.
IPSec has two modes of operation:</p>
<ul>
<li>transport mode - encrypts the payloads of the IP datagrams, but not
the headers. This mode is can secure the direct traffic between two
hosts. Similar to , routers between the hosts can still see the IP
addresses of the hosts and the ports they are communicating on</li>
<li>tunneling mode - encrypts the entire IP datagram and encapsulates it
in a new IP datagram with an unencrypted header. This mode is often used
to securely connect a client to a server that can decrypt the
encapsulated IP datagrams and forward them to their destination. This
way the VPN client can hide the IP addresses of the final destinations
of the traffic from hosts between itself and the VPN server. Depending
on the use-case, the VPN server could either facilitate the client’s
secure access to other resources on the virtual network, or provide
anonymity to the VPN client by hiding its IP address from the hosts its
communicating with on the public Internet.</li>
</ul>
<!-- encrypting the IP datagrams between two hosts. IPSec is similar in purpose to TLS but operates at the Network Layer (L3).  -->
<!-- \todo{tls requires the clients to be configured with a certificate for the server, IPSec needs to server to also be configured with a certificate for the client.} -->
<!-- \todo{tls works in browsers, IPSec works at the OS level} -->
<h5 data-number="2.1.2.2.2" id="openvpn-protocol"><span
class="header-section-number">2.1.2.2.2</span> OpenVPN Protocol</h5>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h5 data-number="2.1.2.2.3" id="wireguard"><span
class="header-section-number">2.1.2.2.3</span> WireGuard</h5>
<p>WireGuard <span class="citation"
data-cites="donenfeldWireGuardNextGeneration2017">(Donenfeld
2017)</span> is a more recent protocol with a design informed by lessons
learned from IPSec and OpenVPN and a key management approach inspired by
. It is a lower-level protocol that focuses on configuration simplicity
while network topology, peer discovery and key distribution are left as
a responsibility of higher-level systems that use it as a building
block. Wireguard is implemented as a Layer 3 overlay over UDP tunnels.
WireGuard has both user-space implementations that use a TUN driver and
also has direct support built into the Linux Kernel since version 5.6
(May 2020). The kernel implementation allows for better performance
because it does not need to copy packets between the kernel and
user-space memory.</p>
<p>WireGuard’s cryptography is based on the <strong>Noise Protocol
Framework</strong><span class="citation" data-cites="noiseDocs">(Perrin
2018)</span>. Noise is another recent effort that applies the ideas of
TLS in a simplified way. It serves as a blueprint for designing
use-case-specific protocols for establishing secure communication
channels based on handshake patterns. It powers the end-to-end
encryption in messaging applications such as WhatsApp and Signal, and
software such as WireGuard and Nebula. </p>
<p>The snippets below show a minimal set of configuration options that
need to be provided for two peers to be able to form secure tunnels with
each other.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode ini"><code class="sourceCode ini"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># peer1.conf</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[Interface]</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Address </span><span class="ot">=</span><span class="st"> 101.0.0.1/32</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">ListenPort </span><span class="ot">=</span><span class="st"> </span><span class="dv">53063</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">PrivateKey </span><span class="ot">=</span><span class="st"> ePTiXXhHjvAHdWUr8Bimk30n0gh3m241RAzsN0JZDW0=</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">[Peer]</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">PublicKey </span><span class="ot">=</span><span class="st"> BSn0ejd1Y3bKuD+Xpg0ZZeOf+Ies/oql0NZxw+SOmkc=</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">AllowedIPs </span><span class="ot">=</span><span class="st"> 101.0.0.2/32</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Endpoint </span><span class="ot">=</span><span class="st"> peer1.example.com:38133</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ini"><code class="sourceCode ini"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># peer2.conf</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[Interface]</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Address </span><span class="ot">=</span><span class="st"> 101.0.0.2/32</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">ListenPort </span><span class="ot">=</span><span class="st"> </span><span class="dv">38133</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">PrivateKey </span><span class="ot">=</span><span class="st"> sN/d6XUPEVPGSziVgCCOnOivDK+qAoYC3nxnssQ5Rls=</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">[Peer]</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="dt">PublicKey </span><span class="ot">=</span><span class="st"> e/TxvPmrgcc1G4cSH2bHv5J0PRHXKjYxTFoU8r+G93E=</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="dt">AllowedIPs </span><span class="ot">=</span><span class="st"> 101.0.0.1/32</span></span></code></pre></div>
<p>Each peer has a public/private key pair that is used for
authentication and encryption based on the Noise Protocol Framework
<span class="citation" data-cites="noiseDocs">(Perrin 2018)</span>. The
<code>Address</code> field specifies the virtual IP address that the
local network interface will use, while the <code>AllowedIPs</code>
field specifies what virtual IP addresses are associated with a peer’s
public key. A peer’s <code>Endpoint</code> field specifies the URL at
which it can be reached. Only one of the peers must be configured with a
reachable endpoint for the other one. In the above example once
<code>peer1</code> initiates communication with <code>peer2</code>,
<code>peer2</code> will learn the current endpoint of <code>peer1</code>
and will be able to communicate back with it.</p>
<p></p>
<h3 data-number="2.1.3"
id="multiparty-communication---barriers-and-traversal"><span
class="header-section-number">2.1.3</span> Multiparty Communication -
Barriers and Traversal</h3>
<p>The version of the Internet Protocol, that was originally deployed
globally (IPv4), uses 32-bit numbers as IP addresses, allowing for
around 4 billion unique addresses. Due to the popularity of the
Internet, there are many more devices than available IPv4 addresses,
which has caused challenges. IPv6 is a newer version of the protocol
that uses a larger 128-bit address space which is sufficient for
assigning 100 addresses for each atom on Earth. However, its adoption
has been slow, as according to Google<span class="citation"
data-cites="IPv6Google">(Google 2023)</span> as of 2023 around 41% of
their users access their services over IPv6. Additionally, despite that
IPv6 allows for all devices to be addressable on the Internet, for
security reasons, most of them would use firewalls to block incoming
remote traffic that is not associated with outgoing connections.</p>
<p>A widespread solution to the addressing problem is . It allows many
devices without globally unique IP addresses to initiate connections to
publicly addressable devices on the Internet via a limited number of
gateways that must have globally unique IP addresses. A NAT gateway
replaces the local source IP address of each outgoing IP datagram with
its own public IP address before passing it on to the next link on the
way to the destination while maintaining a mapping between the source
and destination IPs in a translation table. The destination host can
then address its responses back to the NAT gateway’s public IP address,
which in turn replaces its own IP from the incoming datagrams with the
IP of the local device and forwards them to it. If the IP datagrams
encapsulate TCP/UDP packets, the gateway additionally rewrites the
source and destination ports, which means that NAT techniques can be
placed somewhere between Layers 3 and 4 of the OSI model.</p>
<p>The effect of NAT on connectivity is similar to an IPv6 firewall as
they both allow devices on a local network to initiate bidirectional
communication to remote devices with public IP addresses, but
connections cannot be natively initiated by the remote devices. As
Figure shows, it follows that when two devices are behind separate NATs,
neither can contact the other first. <strong>Client/Server</strong>
communication is less affected by this limitation because Servers are
usually deployed to a public IP address that can be contacted by Clients
with local IP addresses. <strong>Peer-to-Peer</strong> communication,
however, is more challenging because the peers are often devices in
separate residential networks behind different NATs. Several <strong>NAT
traversal</strong> techniques try to solve this with different
performance tradeoffs and success that varies depending on the NAT <span
class="citation" data-cites="natBehaviorRFC">(Jennings and Audet
2007)</span> and its behavior when mapping ports and IP addresses. </p>
<figure>
<img src="thesis/../figures/nat-intro.png" style="height:25.0%"
alt="Two parties behind separate NATs" />
<figcaption aria-hidden="true">Two parties behind separate
NATs</figcaption>
</figure>
<p>One approach based on the Client/Server model is to use a publicly
addressable <strong>relay</strong> server that is contacted by the NATed
devices and then forwards the Peer-to-Peer traffic to the intended
recipient. Compared to direct communication, relaying results in a
higher network latency due to the longer path that each packet must
travel. Maintaining a relay server requires some technical expertise and
may be costly depending on the expected throughput. Despite the
drawbacks, relaying works under most networking scenarios and is
therefore often used as a fallback in case all other approaches fail to
find a direct path. Protocols such as <span class="citation"
data-cites="turnRFC">(Reddy.K et al. 2020)</span> and <span
class="citation" data-cites="derpDocs">(Tailscale 2022)</span> can be
used to securely implement relaying.</p>
<p>The NAT gateway in many residential networks is a Router device under
the customer’s control that has a statically or dynamically assigned
public IP address. Most routers can be manually configured through their
admin page to forward all traffic that arrives at a given port to a
specific device on the local network. Remote applications can then
initiate a connection to the local device if they know the IP address of
the router and the forwarded port. The manual configuration, however,
can be inconvenient and many users may be unaware of that setting
because it is not necessary for the more straightforward Client/Server
communications. Some routers also support programmatic configuration of
port forwarding via a Layer 7 protocol like or its successors and .
However, these protocols are not always supported and are often disabled
by the local network administrators due to security concerns related to
bugs in their implementation, vulnerable IOT devices on the local
network or malicious programs being able to expose local devices to the
internet.</p>
<p>An efficient NAT traversal approach that works with some types of
NATs is to use <span class="citation"
data-cites="stunRFC">(Petit-Huguenin et al. 2020)</span> in combination
with UDP hole punching (Figure ). STUN is a protocol operating at Layer
7 that allows a client application to detect the presence of NAT
gateways on the network path to a public STUN server, and identify their
types and the public IP address that they map to externally. The process
usually involves the following steps:</p>
<ol type="1">
<li>An application sends UDP datagrams to the STUN server</li>
<li>The STUN server responds with the source IP address and port
specified inside the datagrams</li>
<li>The application compares its own endpoint with the source endpoint
observed by the STUN server and if the values differ, it can be inferred
that they were rewritten by a NAT. Additional STUN servers are contacted
to determine if the NAT maps IPs and ports in a predictable
fashion.</li>
</ol>
<p>UDP hole punching is a related technique that, depending on the NAT
types, can allow direct communication between two applications behind
separate NATs. The applications must discover each other’s externally
mapped endpoints, perhaps via the STUN server. If the NATs use the same
external port regardless of the remote destination, the two applications
can:</p>
<ol type="1">
<li>simultaneously send UDP packets to each other’s external
endpoints.</li>
<li>their respective NATs will see the outgoing connection to the other
peer and create a port mapping for the reverse connection - a “punched
hole”</li>
<li>when the incoming traffic arrives from it and forward it
correctly.</li>
</ol>
<p>NATs that map different ports per remote destination sometimes
allocate port numbers predictably, which can be used by the peers to try
to guess the port that will be opened by the opposing side’s NAT.</p>
<figure>
<img src="thesis/../figures/nat-traversal.png" style="height:25.0%"
alt="NAT traversal via STUN" />
<figcaption aria-hidden="true">NAT traversal via STUN</figcaption>
</figure>
<p>In mobile networks like 4G and 5G, the often utilizes a as part of
their infrastructure, while all devices under the user’s control,
including the router, only have local IP addresses. STUN techniques
would fail to discover a direct path between two parties behind separate
CGNATs or other unpredictable NAT algorithms. The only remaining
possibility is to relay the traffic via a publicly reachable third-party
host using a protocol similar to TURN. </p>
<p> is a protocol that describes a standard way for peers to gather
candidate addresses for direct communication via STUN and TURN and then
exchange them via a signaling server. The protocol continuously checks
which candidates provide the best connection and adjusts them.</p>
<p> is a framework that allows peer-to-peer communications between Web
applications in Web browsers. Web applications are normally limited to
HTTP connections and cannot use raw UDP or TCP connections. WebRTC
implements the ICE functionality in Web browsers and provides an API to
Web applications.</p>
<h2 data-number="2.2" id="sec:overlays"><span
class="header-section-number">2.2</span> Overlay Networks</h2>
<p>An <strong>overlay network</strong> is a higher-order solution that
provides additional networking functionality on top of an existing
underlay network like the Internet. From the point of view of its
consumers, an overlay network may appear at a lower OSI layer, despite
being implemented using protocols from higher layers. For example can
provide virtual interfaces to the Operating System at the Link layer
(L2) or Network layer (L3) while being implemented on top of a Transport
layer (L4) protocol like or a Presentation layer (L6) protocol like .
Virtual IP addresses can be assigned to the hosts and applications that
are already designed to work with TCP/IP can directly use the virtual
network interfaces via the regular TCP/IP mechanisms provided by the
operating system.</p>
<p>Other overlay networks are both implemented and used at the
Application layer (L7). To communicate via such an overlay network,
applications often have to implement specific functionality in their
software by utilizing a framework or a library.</p>
<p>Figure shows an approximate OSI model mapping of several protocols
and network overlay solutions from the point of view of the systems that
use them and the arrows show dependency relations between them.</p>
<figure>
<embed src="thesis/../figures/osi-map-overlays.drawio.pdf"
style="height:90.0%" />
<figcaption aria-hidden="true">OSI model mapping of various protocols
</figcaption>
</figure>
<h3 data-number="2.2.1"
id="network-layer-l3-and-data-link-l2-overlay-networks"><span
class="header-section-number">2.2.1</span> Network layer (L3) and Data
Link (L2) Overlay Networks</h3>
<h4 data-number="2.2.1.1" id="traditional-vpns"><span
class="header-section-number">2.2.1.1</span> Traditional VPNs</h4>
<p>Layer 2 virtual networks provide a virtual network switch that allows
remote machines to be on the same virtual LAN and share the same IP
address range. Layer 3 virtual networks provide a virtual network router
that allows remote machines to be on separate LANs. Depending on the
specific implementation, the overlay network can either be implemented
directly in the Operating System’s kernel, or on top of a driver like or
.</p>
<ul>
<li>Layer 2 vs Layer 3 Networks
<ul>
<li>Layer 2 overlays bridge networks
<ul>
<li>virtual network switch</li>
<li>remote machines are on the same virtual LAN and can share the same
IP address range</li>
<li>allows broadcast/multicast</li>
<li>TAP driver</li>
</ul></li>
<li>Layer 3 overlays route traffic between separate local networks
<ul>
<li><p>virtual network router</p></li>
<li><p>remote machines are on separate LANs</p></li>
<li><p>simpler to configure</p></li>
<li><p>TUN driver</p></li>
<li><p>the low-level solutions from the previous section are complex to
set up.</p></li>
<li><p>overlay networks package some of those solutions for a specific
use case Most overlay networks use a combination of the NAT traversal
techniques mentioned previously. They can be placed in Layers 2, 3 or 7.
Layer 2 overlays act as a virtual network switch, while Layer 3 overlays
act as a virtual network router. Layer 7 overlays are implemented in
user-space as libraries or applications that run on top of the network
stack of the host operating system. Layer 2 and 3 overlays can either be
implemented as kernel modules or as user-space applications that use a
<strong>TUN/TAP</strong> driver to interface with the kernel.</p></li>
</ul>
<ul>
<li>The term “VPN” is somewhat overloaded as it can refer to different
related concepts.</li>
</ul>
are implemented as Layer 2 or 3 network overlays. They are commonly used
for securely connecting machines from different . They provide software
emulation of a network interface controller via a TUN/TAP driver on the
operating system level and allow other software to transparently use the
functionality of the suite without requiring extra changes. Traditional
such as IPSec <span class="citation" data-cites="ipSecRFC">(Frankel and
Krishnan 2011)</span> and OpenVPN <span class="citation"
data-cites="openVPNDocs">(OpenVPN 2022)</span> use a centralized service
that all (encrypted) client communications must pass through. This
introduces a single point of failure and a potential bottleneck that
might negatively impact the performance of the multiparty computations
due to their nature.</li>
</ul></li>
</ul>
<h5 data-number="2.2.1.1.1" id="openvpn-clientserver"><span
class="header-section-number">2.2.1.1.1</span> OpenVPN
Client/Server</h5>
<p>We already discussed the VPN protocol behind OpenVPN. Here we will go
into the client and server software and how they are implemented and
discuss the typical network topologies.</p>
<h4 data-number="2.2.1.2" id="mesh-vpns"><span
class="header-section-number">2.2.1.2</span> Mesh VPNs</h4>
<ul>
<li>Tinc</li>
<li>N2N</li>
<li>Tailscale</li>
<li>Nebula</li>
<li>ZeroTier</li>
</ul>
<p>Mesh such as Tinc <span class="citation"
data-cites="tincDocs">(Sliepen 2022)</span>, Tailscale <span
class="citation" data-cites="tailscaleDocs">(Tailscale n.d.)</span> and
Nebula <span class="citation" data-cites="nebulaDocs">(Defined
2022)</span> utilize NAT Traversal techniques to create direct links
between the clients for the data traffic. Authentication, authorization
and traffic encryption are performed using certificates based on public
key cryptography.</p>
<p>All three are open-source, except Tailscale’s coordination service
which handles peer discovery and identity management. Headscale <span
class="citation" data-cites="fontJuanfontHeadscale2022">(Font [2020]
2022)</span> is a community-driven open-source alternative for that
component. Tinc is the oldest of the three but has a relatively small
community. It is mainly developed by a single author and appears to be
more academic than industry motivated. Nebula and Tailscale are both
business driven. Tailscale was started by some high-profile ex-googlers
and is the most end-user-focused of the three, providing a service that
allows people to sign up using identity providers such as Google,
Microsoft, GitHub and others. They also provide an Admin console that
allows a user to easily add their personal devices to a network or share
them with others. It also has support for automation tools like
Terraform for creating authorization keys and managing an based
firewall. Nebula was originally developed at the instant messaging
company Slack to create overlay networks for their cross-region cloud
infrastructure, but the authors later started a new company and are
currently developing a user-centric platform similar to Tailscale’s.
Nebula is more customizable than Tailscale and since it is completely
open-source it can be adapted to different use cases, but it is also
more involved to set up. A certificate authority needs to be configured
for issuing the identities of the participating hosts. Furthermore,
publicly accessible coordination servers need to be deployed to
facilitate the host discovery. Tailscale employs a distributed relay
network of servers, while Nebula can be configured to route via one of
the other peers in the VPN.</p>
<h3 data-number="2.2.2" id="application-layer-l7-network-overlays"><span
class="header-section-number">2.2.2</span> Application Layer (L7)
Network Overlays</h3>
<h4 data-number="2.2.2.1" id="openziti"><span
class="header-section-number">2.2.2.1</span> OpenZiti</h4>
<ul>
<li><p>uses relays</p></li>
<li><p>libP2P</p></li>
<li><p>ngrok</p></li>
<li><p>TOR</p></li>
<li><p>BitTorrent</p></li>
<li><p>IPFS</p></li>
<li><p>Ethereum</p></li>
<li><p>Teleport</p></li>
<li><p>Freenet</p></li>
</ul>
<h1 data-number="3" id="proof-of-concepts-and-evaluation"><span
class="header-section-number">3</span> Proof of Concepts and
Evaluation</h1>
<h2 data-number="3.1" id="testing-methodology"><span
class="header-section-number">3.1</span> Testing methodology</h2>
<p>In the following chapters, we will design and implement several
solutions for ad hoc MPC sessions based on a subset of the previously
discussed related works:</p>
<ul>
<li>Internet protocol</li>
<li>Wireguard</li>
<li>Tailscale</li>
<li>Headscale</li>
<li>? Headscale with DID identity?</li>
<li>? WebRTC?</li>
<li>A custom solution that automates the WireGuard configuration by
visiting a web page</li>
</ul>
<p>Additionally, we will analyze and compare them in terms of
performance, security and usability</p>
<h3 data-number="3.1.1" id="measuring-performance"><span
class="header-section-number">3.1.1</span> Measuring performance</h3>
<p>During the preparation phase of the project, we developed the
framework which simplifies and automates the process of deploying
machines in different geographical regions, connecting them via an
overlay network and executing multiparty computations between them,
where each machine represents a different party.</p>
<p>To summarize, is a set of scripts that use several automation
tools:</p>
<ul>
<li>Terraform - declarative provisioning</li>
<li>NixOS - declarative Linux distribution</li>
<li>Colmena - declarative deployment for NixOS</li>
<li>PSSH - parallel execution of remote scripts over ssh</li>
<li>DigitalOcean - a cloud provider</li>
</ul>
<p>It allows us to quickly provision cloud virtual machines in multiple
regions and reproducibly deploy all necessary software for running a
multiparty computation over a chosen network overlay solution. The
source code of can be found on <a
href="https://github.com/e-nikolov/mpyc">GitHub</a></p>
<p>Each solution will be deployed using the framework and the
performance will be quantitatively measured in terms of the time it
takes to execute several MPyC demos. The selected demos have different
complexities in terms of communication rounds and message sizes which
will allow us to observe their impact on the overall performance.</p>
<ol type="1">
<li>Secret Santa - high round complexity with small messages</li>
<li>Convolutional Neural Network (CNN) MNIST classifier - low round
complexity with large messages</li>
</ol>
<p>The demos will be configured at three different input size levels</p>
<ul>
<li>Low,</li>
<li>Medium</li>
<li>High</li>
</ul>
<p>Furthermore, the demos will be executed in several networking
scenarios:</p>
<ol type="1">
<li>1-10 parties in the same geographic region</li>
<li>1-10 parties evenly distributed across two nearby regions</li>
<li>1-10 parties evenly distributed across two distant regions</li>
<li>1-10 parties distributed across multiple distant regions</li>
</ol>
<h3 data-number="3.1.2" id="security"><span
class="header-section-number">3.1.2</span> Security</h3>
<p>We will analyze aspects such as</p>
<ul>
<li>key distribution</li>
<li>trust model - are there any trusted third parties and what would be
the consequences if they are corrupted or breached</li>
<li>traffic encryption</li>
<li>identity strength</li>
</ul>
<h3 data-number="3.1.3" id="usability"><span
class="header-section-number">3.1.3</span> Usability</h3>
<p>For each solution, we will describe the steps that the parties need
to perform to execute a joint multiparty computation. Those steps will
be analyzed in terms of:</p>
<ul>
<li>Complexity - how much technical expertise is expected from the
parties to be able to execute the steps</li>
<li>Initial effort - how much effort is each party expected to put in
preparing for their first joint computation</li>
<li>Repeated effort - after the initial setup, how much effort is
required to perform another computation
<ul>
<li>with the same set of parties</li>
<li>with another set of parties</li>
</ul></li>
<li>Finalization effort - how much effort is required to finalize the
MPC session once it is complete and clean up any left-over artifacts or
resources so that the machine of each party is in its original
state</li>
</ul>
<h2 data-number="3.2" id="internet-protocol-based-solution"><span
class="header-section-number">3.2</span> Internet Protocol based
solution</h2>
<p>This solution focuses on directly using the internet protocol without
involving an overlay network. Our goal is to analyze the implications of
using only the functionalities that MPyC directly supports to serve as
the reference for our later experiments.</p>
<h3 data-number="3.2.1" id="implementation-details"><span
class="header-section-number">3.2.1</span> Implementation details</h3>
<p>We will manually set up the multiparty computations via the public IP
addresses of the machines and DNS.</p>
<h3 data-number="3.2.2" id="performance-analysis"><span
class="header-section-number">3.2.2</span> Performance analysis</h3>
<h3 data-number="3.2.3" id="security-analysis"><span
class="header-section-number">3.2.3</span> Security analysis</h3>
<h3 data-number="3.2.4" id="usability-analysis"><span
class="header-section-number">3.2.4</span> Usability analysis</h3>
<h2 data-number="3.3" id="wireguard-based-solution"><span
class="header-section-number">3.3</span> WireGuard based solution</h2>
<p>This solution creates an overlay network by manually configuring
WireGuard on each machine.</p>
<h3 data-number="3.3.1" id="implementation-details"><span
class="header-section-number">3.3.1</span> Implementation details</h3>
<h3 data-number="3.3.2" id="performance-analysis"><span
class="header-section-number">3.3.2</span> Performance analysis</h3>
<h3 data-number="3.3.3" id="security-analysis"><span
class="header-section-number">3.3.3</span> Security analysis</h3>
<h3 data-number="3.3.4" id="usability-analysis"><span
class="header-section-number">3.3.4</span> Usability analysis</h3>
<h2 data-number="3.4" id="tailscale-based-solution"><span
class="header-section-number">3.4</span> Tailscale based solution</h2>
<p>Tailscale is a VPN solution that configures a mesh of direct
Wireguard tunnels between the peers.</p>
<h3 data-number="3.4.1" id="implementation-details"><span
class="header-section-number">3.4.1</span> Implementation details</h3>
<h3 data-number="3.4.2" id="performance-analysis"><span
class="header-section-number">3.4.2</span> Performance analysis</h3>
<h3 data-number="3.4.3" id="security-analysis"><span
class="header-section-number">3.4.3</span> Security analysis</h3>
<h4 data-number="3.4.3.1" id="trust-model"><span
class="header-section-number">3.4.3.1</span> Trust model</h4>
<p>There is a centralized service that deals with the key distribution,
which needs to be trusted to provide the correct public keys for the
correct parties</p>
<h4 data-number="3.4.3.2" id="identity"><span
class="header-section-number">3.4.3.2</span> Identity</h4>
<p>Identity is based on third party identity providers such as Microsoft
and GitHub</p>
<ul>
<li>Magic DNS</li>
<li><h3 id="usability-analysis">Usability analysis</h3></li>
</ul>
<p>With tailscale each party needs to</p>
<ul>
<li>register a Tailscale account</li>
<li>Download and install tailscale on the machine they want to run a
multiparty computation</li>
<li>Run tailscale on their machine and logs into their account in order
to link it to their own Tailnet</li>
<li>Share their Tailscale machine with the Tailnets of each of the other
parties</li>
<li>Download the demo they want to run</li>
<li>Form the flags for running the chosen demo
<ul>
<li>add -P $HOST:$PORT for each party using their Tailscale
hostname/virtual IP</li>
</ul></li>
<li>Run the demo</li>
</ul>
<h2 data-number="3.5" id="headscale-based-solution"><span
class="header-section-number">3.5</span> Headscale based solution</h2>
<p>This solution is similar to the Tailscale one, but it uses Headscale
- a self-hosted open-source alternative to the closed-source Tailscale
coordination service.</p>
<h3 data-number="3.5.1" id="implementation-details"><span
class="header-section-number">3.5.1</span> Implementation details</h3>
<h3 data-number="3.5.2" id="performance-analysis"><span
class="header-section-number">3.5.2</span> Performance analysis</h3>
<h3 data-number="3.5.3" id="security-analysis"><span
class="header-section-number">3.5.3</span> Security analysis</h3>
<h4 data-number="3.5.3.1" id="trust-model"><span
class="header-section-number">3.5.3.1</span> Trust model</h4>
<p>There still is a centralized service like in the Tailscale solution,
but here it is self-deployed.</p>
<h4 data-number="3.5.3.2" id="identity"><span
class="header-section-number">3.5.3.2</span> Identity</h4>
<h3 class="unnumbered" id="usability-analysis">Usability analysis</h3>
<div id="refs" class="references csl-bib-body hanging-indent"
role="doc-bibliography">
<div id="ref-nebulaDocs" class="csl-entry" role="doc-biblioentry">
Defined. 2022. <span>“Nebula: <span>Open Source Overlay
Networking</span> | <span>Nebula Docs</span>.”</span> 2022. <a
href="https://docs.defined.net/docs/">https://docs.defined.net/docs/</a>.
</div>
<div id="ref-donenfeldWireGuardNextGeneration2017" class="csl-entry"
role="doc-biblioentry">
Donenfeld, Jason A. 2017. <span>“<span>WireGuard</span>: <span>Next
Generation Kernel Network Tunnel</span>.”</span> In <em>Proceedings 2017
<span>Network</span> and <span>Distributed System Security
Symposium</span></em>. <span>San Diego, CA</span>: <span>Internet
Society</span>. <a
href="https://doi.org/10.14722/ndss.2017.23160">https://doi.org/10.14722/ndss.2017.23160</a>.
</div>
<div id="ref-fontJuanfontHeadscale2022" class="csl-entry"
role="doc-biblioentry">
Font, Juan. (2020) 2022. <em>Juanfont/Headscale</em>. <a
href="https://github.com/juanfont/headscale">https://github.com/juanfont/headscale</a>.
</div>
<div id="ref-ipSecRFC" class="csl-entry" role="doc-biblioentry">
Frankel, Sheila, and Suresh Krishnan. 2011. <span>“<span>IP
Security</span> (<span>IPsec</span>) and <span>Internet Key
Exchange</span> (<span>IKE</span>) <span>Document
Roadmap</span>.”</span> Request for Comments RFC 6071. <span>Internet
Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC6071">https://doi.org/10.17487/RFC6071</a>.
</div>
<div id="ref-IPv6Google" class="csl-entry" role="doc-biblioentry">
Google. 2023. <span>“<span>IPv6</span> – <span>Google</span>.”</span>
May 21, 2023. <a
href="https://www.google.com/intl/en/ipv6/statistics.html">https://www.google.com/intl/en/ipv6/statistics.html</a>.
</div>
<div id="ref-ipv4RFC" class="csl-entry" role="doc-biblioentry">
<span>“Internet <span>Protocol</span>.”</span> 1981. Request for
Comments RFC 791. <span>Internet Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC0791">https://doi.org/10.17487/RFC0791</a>.
</div>
<div id="ref-natBehaviorRFC" class="csl-entry" role="doc-biblioentry">
Jennings, Cullen Fluffy, and Francois Audet. 2007. <span>“Network
<span>Address Translation</span> (<span>NAT</span>) <span>Behavioral
Requirements</span> for <span>Unicast UDP</span>.”</span> Request for
Comments RFC 4787. <span>Internet Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC4787">https://doi.org/10.17487/RFC4787</a>.
</div>
<div id="ref-sshRFC" class="csl-entry" role="doc-biblioentry">
Lonvick, Chris M., and Tatu Ylonen. 2006. <span>“The <span>Secure
Shell</span> (<span>SSH</span>) <span>Protocol
Architecture</span>.”</span> Request for Comments RFC 4251.
<span>Internet Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC4251">https://doi.org/10.17487/RFC4251</a>.
</div>
<div id="ref-openVPNDocs" class="csl-entry" role="doc-biblioentry">
OpenVPN. 2022. <span>“Community <span>Resources</span>.”</span>
<span>OpenVPN</span>. 2022. <a
href="https://openvpn.net/community-resources/">https://openvpn.net/community-resources/</a>.
</div>
<div id="ref-noiseDocs" class="csl-entry" role="doc-biblioentry">
Perrin, Trevor. 2018. <span>“The <span>Noise Protocol
Framework</span>,”</span> July.
</div>
<div id="ref-stunRFC" class="csl-entry" role="doc-biblioentry">
Petit-Huguenin, Marc, Gonzalo Salgueiro, Jonathan Rosenberg, Dan Wing,
Rohan Mahy, and Philip Matthews. 2020. <span>“Session <span>Traversal
Utilities</span> for <span>NAT</span> (<span>STUN</span>).”</span>
Request for Comments RFC 8489. <span>Internet Engineering Task
Force</span>. <a
href="https://doi.org/10.17487/RFC8489">https://doi.org/10.17487/RFC8489</a>.
</div>
<div id="ref-turnRFC" class="csl-entry" role="doc-biblioentry">
Reddy.K, Tirumaleswar, Alan Johnston, Philip Matthews, and Jonathan
Rosenberg. 2020. <span>“Traversal <span>Using Relays</span> Around
<span>NAT</span> (<span>TURN</span>): <span>Relay Extensions</span> to
<span>Session Traversal Utilities</span> for <span>NAT</span>
(<span>STUN</span>).”</span> Request for Comments RFC 8656.
<span>Internet Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC8656">https://doi.org/10.17487/RFC8656</a>.
</div>
<div id="ref-httpsRFC" class="csl-entry" role="doc-biblioentry">
Rescorla, Eric. 2000. <span>“<span>HTTP Over TLS</span>.”</span> Request
for Comments RFC 2818. <span>Internet Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC2818">https://doi.org/10.17487/RFC2818</a>.
</div>
<div id="ref-tlsRFC" class="csl-entry" role="doc-biblioentry">
———. 2018. <span>“The <span>Transport Layer Security</span>
(<span>TLS</span>) <span>Protocol Version</span> 1.3.”</span> Request
for Comments RFC 8446. <span>Internet Engineering Task Force</span>. <a
href="https://doi.org/10.17487/RFC8446">https://doi.org/10.17487/RFC8446</a>.
</div>
<div id="ref-tincDocs" class="csl-entry" role="doc-biblioentry">
Sliepen, Guus. 2022. <span>“Tinc <span>Docs</span>.”</span> November 30,
2022. <a
href="https://www.tinc-vpn.org/docs/">https://www.tinc-vpn.org/docs/</a>.
</div>
<div id="ref-derpDocs" class="csl-entry" role="doc-biblioentry">
Tailscale. 2022. <span>“<span>DERP Servers</span>.”</span>
<span>Tailscale</span>. December 21, 2022. <a
href="https://tailscale.com/kb/1232/derp-servers/">https://tailscale.com/kb/1232/derp-servers/</a>.
</div>
<div id="ref-tailscaleDocs" class="csl-entry" role="doc-biblioentry">
———. n.d. <span>“Tailscale.”</span> <span>Tailscale</span>. Accessed
November 30, 2022. <a
href="https://tailscale.com/kb/">https://tailscale.com/kb/</a>.
</div>
</div>

<p>The field of Secure Multiparty Computation provides methods for
jointly computing functions without revealing their private inputs from
multple parties. This master thesis assignment focuses on the MPyC
framework for MPC and explores various approaches for connecting the
parties via the internet. A technical survey was performed in the
preparation phase to identify viable techniques and tools to achieve
that. Furthermore a test environment dubbed <span
class="math inline"><em>E</em><sup>3</sup></span> was developed to
support the exploration process that will take place during the
implementation phase of the assignment. It is composed of a combination
of physical and virtual machines that are able to execute a multiparty
computation together using MPyC. It employs several declarative
Infrastructure as Code tools to automate the deployment process and make
it reproducible. Specifically, Terraform is used for provisioning NixOS
virtual machines on the DigitalOcean cloud provider and Colmena is used
for remotely deploying software to them. The reference implementation
described in this report uses the Tailscale mesh VPN for connectivity,
and a number of additional implementations are planned for the next
phase of the project.</p>
<h1 data-number="1" id="introduction"><span
class="header-section-number">1</span> Introduction</h1>
<p>This report will present the results of the preparation phase of the
master thesis project titled “Secure Sessions for Ad Hoc Multiparty
Computation in MPyC”. The goal of this phase is to gain sufficient
insight into the topic, perform some preliminary tasks and propose a
plan with well defined goals for the implementation phase of the
project.</p>
<h2 data-number="1.1" id="background"><span
class="header-section-number">1.1</span> Background</h2>
<p> is a set of techniques and protocols for computing a function over
the secret inputs of multiple parties without revealing their values,
but only the final result. A good overview can be found on
Wikipedia<span class="citation" data-cites="wikiMPC">(Wikipedia
2022)</span>. Yao’s Millionaires’ Problem<span class="citation"
data-cites="yaoProtocolsSecureComputations1982">(Yao 1982)</span> is one
famous example in which a number of millionaires want to know who is
richer without revealing their net worths. Other practical
applications<span class="citation"
data-cites="laudApplicationsSecureMultiparty2015">(Laud and Kamm
2015)</span> include electronic voting, auctions or even machine
learning<span class="citation"
data-cites="knottCrypTenSecureMultiParty2022">(Knott et al. 2022)</span>
where one party’s private data can be used as an input for another
party’s private machine learning model.</p>
<p>The general process is that each party uses a scheme like <span
class="citation" data-cites="shamirHowShareSecret1979">(Shamir
1979)</span> to split its secret input into shares and sends one to each
of the other parties. A protocol involving multiple communication rounds
and further re-shares of intermediate secret results is used by the
parties so that each of them can compute the final result from the
shares it has received.</p>
<p>A number of frameworks have been developed for various programming
languages and security models. As part of this project we will focus our
efforts on <strong>MPyC</strong><span class="citation"
data-cites="mpycHome mpycSource">(Schoenmakers 2022, [2018] 2022)</span>
- an opensource Python framework developed primarily at TU Eindhoven,
but our results should be applicable to others as well.</p>
<p>To help us determine the types of solutions we need to consider, we
can group the potential users of the MPyC framework into three broad
categories: casual users, power users and enterprises.</p>
<p>We define <strong>casual users</strong> as people who are used to
Windows or Mac, prefer software installers to package managers, programs
rather than based ones and do not feel comfortable with manually
modifying their systems or using scripts.</p>
<p>We define <strong>power users</strong> as users who manage a number
of personal physical machines and may have some familiarity with Linux,
terminals and shell scripting. They are assumed to be able to execute
the necessary steps to setup a machine given a guide.</p>
<p>For our purposes we define <strong>enterprises</strong> as companies
with operations departments that manage their IT infrastructure and
optimize for scale. They usually have large numbers of Linux based
servers which are a combination of physical, virtual and container
based. Those can be deployed either in the cloud or on premise in an
automated way using tools.</p>
<h2 data-number="1.2" id="problem-description"><span
class="header-section-number">1.2</span> Problem description</h2>
<p>MPyC supports connections from the suite between the participants but
it does not currently provide a service discovery mechanism. Before
performing a joint computation, all parties must know and be able to
reach each other’s endpoints - either via a local address on a , or via
a public address or the on the internet. This is not likely to pose a
problem for most enterprise users, who are usually already exposing some
public services, e.g. their website. However, most casual users who are
not experts typically do not own a domain name nor know how to configure
a publicly accessible server. Due to the limited supply of addresses
supported by v4 and the slow adoption of v6, most do not allocate a
public address for each machine in the home networks of their
residential customers. Usually only their router has a temporary public
address and it utilizes techniques such as in order to enable the other
local machines to initiate remote internet connections. However,
connections to them cannot be initiated from outside the without
manually configuring port forwarding in the router to send the
appropriate traffic to the intended machine. This poses some challenges
and limits the usability of MPyC in every day scenarios due to the
inherently nature of the involved communications.</p>
<h2 data-number="1.3" id="research-questions"><span
class="header-section-number">1.3</span> Research questions</h2>
<p>Based on the problem description above, we formulate the following
central research question:</p>
<p><em>How can MPyC be extended to enable casual users, power users and
enterprises with limited prior knowledge of each other to discover each
other and perform a secure multiparty computation under diverse
networking conditions?</em></p>
<p>We further identify the following sub-questions:</p>
<ul>
<li><em>What deployment strategies should be supported in order to
accommodate the potential users of MPyC programs?</em></li>
</ul>
<p>Depending on the technical background of a user and their typical
computing usage, they might have different expectations for how to
execute their part of the joint multiparty computation, e.g. enterprises
might expect support for automation tools, while casual users could
expect simplicity. There should be some safety (not necessarily
security) mechanism for detecting and preventing mistakes where the
users are accidentally executing incompatible MPyC
programs/versions.</p>
<ul>
<li><em>What are the most suitable approaches for a party to obtain an
identity and prove it to other parties for the purposes of
MPC?</em></li>
</ul>
<p>A party’s digital identity is a persistent mechanism that allows
others to provably track it across digital interactions with the party.
An identity can either be issued by a digital authority, e.g. an
organization like google, or a country’s government or it can be
self-issued. Depending on the method, an identity verification can
involve demonstrating a cryptographic proof of ownership of a public
key, or separate communication with the digital authority.</p>
<ul>
<li><em>What mechanisms can be used by the parties to initially get in
contact and discover each other’s identities?</em></li>
</ul>
<p>Different approaches should be considered based on the types of users
and their prior relationships. Some examples could be for companies to
publicly post their identities on their websites, end-users who know
each other could use social media or group chats and if they do not know
each other, they could use an (anonymous) matchmaking service.</p>
<ul>
<li><em>How can the parties establish communication channels with each
other based on the chosen identity solutions under diverse networking
conditions?</em></li>
</ul>
<p>As previously mentioned, some parties could be on a home network and
not have a public , which may require considering approaches that use a
mediator.</p>
<ul>
<li><em>How can the parties communicate securely as part of the MPC
execution? To what extent can the parties’ privacy be preserved? How
efficiently can this be achieved?</em></li>
</ul>
<p>In order for the execution of an protocol to be secure, it is
important for the parties to be able to cryptographically verify the
identity of a message’s original sender and be certain that nobody other
than themselves can read it. Solutions that do not reveal physically
identifying information such as addresses are also interesting to
consider. The performance overhead of the security mechanisms should be
evaluated.</p>
<h2 data-number="1.4" id="preparation-phase-scope"><span
class="header-section-number">1.4</span> Preparation phase scope</h2>
<p>During the implementation phase, we will answer the posed research
questions of the project after evaluating various connectivity
approaches for MPyC. The scope of the preparation phase will cover a
technical survey to identify some of the tools that can be used and the
development of an that will support the evaluation process in the next
phase. must enable fearless experimentation with different
implementations of the connectivity layer. will focus on being
reproducible by enterprise and power users while keeping it
representative of real world scenarios involving casual users as
well.</p>
<p>Below, we formulate our requirements for and group them in terms of
several important characteristics:</p>
<ul>
<li>Complexity
<ul>
<li>simple - given the limited time of the preparation phase, must focus
on simplicity, e.g. the easiest to implement connectivity approach
should be chosen</li>
<li>extensible - must allow for switching the building blocks during the
next phase of the project, e.g. it should be easy to experiment with
different connectivity approaches in order to measure and compare their
characteristics</li>
</ul></li>
<li>Source code
<ul>
<li>open-source - the source code of the resulting implementation of
must be available in a public repository, e.g. on Github.com</li>
<li>no plaintext secrets such as keys and passwords should be present in
the public repository, but others should be able to easily provide their
own secrets in order to use in their own environment.</li>
</ul></li>
<li>Deployment
<ul>
<li>cross region - the machines should be provisioned in multiple
geographical regions in order to be able to observe the effects of
varying latency on the system</li>
<li>cross platform - in a real world scenario the machines will be
controlled by different parties that run various operating systems,
hardware architectures and deployed using different tools, e.g. Party A
might be an enterprise that uses containers, while Party B is a power
user running a few and Party C ****could be using an ARM-based raspberry
pi</li>
<li>automated - appropriate tools should be chosen to allow
automatically deploying and destroying the runtime environment without
manual intervention other than running a minimal set of commands</li>
<li>reproducible - it should be easy for others to reproduce the test
setup in their own environment</li>
<li>disposable - should be easy to destroy and quickly recreate from
scratch at any time; as in the famous DevOps analogy<span
class="citation" data-cites="biasHistoryPetsVs2016">(Bias 2016)</span>,
it should be based on machines that are like cattle rather than
pets</li>
</ul></li>
<li>Connectivity
<ul>
<li>identity - it must be possible for the machines to communicate based
on a long-lived identity rather than a potentially temporary
address.</li>
<li>secure - a message sent by a party must be readable only by its
intended targets.</li>
<li>authenticated - a party must be able to determine which party a
message was sent by</li>
<li>private - no more information than strictly necessary should be
revealed about a party. Depending on the method of communication, it may
be necessary to choose a tradeoff or introduce a tuning parameter
between performance and privacy.</li>
</ul></li>
</ul>
<h1 data-number="2" id="technical-survey"><span
class="header-section-number">2</span> Technical Survey</h1>
<p>In this chapter we will perform a high level survey of the available
tools and approaches that could be used for and select ones that fit our
requirements. In the next chapter we will go more in depth and cover the
implementation details using those tools.</p>
<p>Since we need to design for a heterogeneous runtime environment, we
need to choose building blocks that are compatible with as many
scenarios as possible while also keeping the complexity low.</p>
<h2 data-number="2.1" id="deployment"><span
class="header-section-number">2.1</span> Deployment</h2>
<p>Our primary users are enterprises and power users. Enterprises can
employ a variety of tools in their infrastructure management
process:</p>
<ul>
<li>provisioning - Terraform<span class="citation"
data-cites="tfDocs">(Hashicorp 2022)</span>, Cloud Formation<span
class="citation" data-cites="cfDocs">(AWS 2022)</span>, etc.</li>
<li>deployment automation - Ansible<span class="citation"
data-cites="ansibleDocs">(Redhat 2022)</span>, Puppet<span
class="citation" data-cites="puppetDocs">(Puppet 2022)</span>, Chef<span
class="citation" data-cites="chefDocs">(Chef 2022)</span>, etc.</li>
<li>container orchestration - Docker Swarm<span class="citation"
data-cites="dockerDocs">(Docker 2022)</span>, Kubernetes<span
class="citation" data-cites="kubeDocs">(Kubernetes 2022)</span>,
etc.</li>
</ul>
<p>According to our definitions, power users typically use physical
machines while enterprises can use both virtual machines and container
orchestration tools. Based on our requirements for we need a cross
region deployment. can be automatically provisioned across different
regions in the cloud using tools. Once provisioned, a is usually managed
via an automation tool that executes a set of deployment steps over SSH.
Those deployment steps can be adapted to physical machines so that power
users can make use of them.</p>
<p>Kubernetes is used for dynamically scaling a large number of
long-running processes across a cluster of within the same geographic
region. Enterprises may wish to run MPyC programs in a Kubernetes
cluster and might benefit from an example of doing so. But for the
purposes of , it does not provide sufficient benefits compared to using
directly, while it adds complexity in terms of deploying multiple
clusters across regions and adding a cross cluster communication
mechanism.</p>
<p>Based on this analysis, we choose to base on a combination of
deployed in the cloud and a set of personal devices owned by the authors
- a Linux laptop, a Windows desktop with Windows Subsystem for Linux,
and an ARM Raspberry Pi 2 to serve as an example of both enterprises and
individual power users.</p>
<p> tools use specifications that are either imperative or declarative.
<strong>Imperative</strong> specifications describe the steps needed to
be executed for the infrastructure to reach the desired state, while
<strong>declarative</strong> specifications describe the desired final
state and let the tool worry about how to get there. Imperative tools
are more likely to suffer from <em>configuration drift</em> - the
infrastructure state might become out of sync with the specification due
to either manual changes or left-over state from previously applied
specifications. On the other hand, if something is removed from a
declarative specification, when it gets applied, the corresponding
resources will also be removed from the infrastructure. In addition,
declarative tools are idempotent - applying the same specification
multiple times in a row does not change the state. Therefore in order to
achieve high reproducibility, we will prefer declarative tools to
imperative ones where possible.</p>
<p>On Linux, software is usually installed via package managers. Most of
the popular Linux distributions such as Ubuntu, Debian, Fedora, Arch use
package managers that only support automating this process via
imperative shell scripts rather than a declarative specification.
Additionally those do not offer an easy way of specifying and locking
the required software versions to a known good configuration that can be
reproduced in the future. NixOS on the other hand is based on the
declarative Nix package manager which does support version locking via
its <strong>flakes</strong> feature. This is why we choose to use the
NixOS operating system for our .</p>
<p>Most of the popular application deployment tools such as Ansible,
Chef and Puppet are either imperative or have limited support for
declarative specifications. Fortunately, the NixOS ecosystem, offers a
number of deployment tools that can apply a declarative specification on
remote hosts:</p>
<ul>
<li>NixOps<span class="citation"
data-cites="nixopsSource nixopsDocs">(NixOps [2011] 2022, 2022)</span> -
official tool</li>
<li>Colmena <span class="citation"
data-cites="colmenaSource colmenaDocs">(Li [2020] 2022,
2022)</span></li>
<li>morph <span class="citation"
data-cites="morphSource">(BiblioteksCenter [2018] 2022)</span></li>
<li>deploy-rs <span class="citation"
data-cites="deployrsSource">(Serokell [2020] 2022)</span></li>
</ul>
<p>NixOps is the official deployment tool for NixOS but it was being
redesigned at the time of writing. The new version was not complete yet
and lacked documentation, while the old one was no longer being
supported and depended on a deprecated version of Python. The rest of
the tools were still actively maintained. Colmena was the best fit for
our use case because it supported both flakes and parallel deploys,
while morph lacked support for flakes and deploy-rs could not deploy to
multiple hosts in parallel.</p>
<p>The declarative tools that were considered for provisioning were
Terraform, Pulumi and Cloud Formation. Cloud Formation only works on AWS
which would prevent us from using it with other cloud providers. Pulumi
is a newer and less proven tool compared to Terraform, which the authors
had more experience with. Therefore our choice was to use Terraform.</p>
<p>We decided to use DigitalOcean as a cloud provider because they are
supported by Terraform and offered free credits for educational use.</p>
<h2 data-number="2.2" id="connectivity"><span
class="header-section-number">2.2</span> Connectivity</h2>
<p>There are a number of approaches for communication between our host
machines. During the preparation phase of the project we will perform a
high level exploration of our options and summarize them. For we will
initially use the simplest to implement one. During the implementation
phase of the project we will go more in depth and implement more
approaches and analyze how they compare to each other in practice.</p>
<h3 data-number="2.2.1" id="virtual-private-networks-vpns"><span
class="header-section-number">2.2.1</span> Virtual Private Networks
(VPNs)</h3>
<p> are commonly used for securely connecting machines from different .
They provide software emulation of a network device on the operating
system level and allow other software to transparently use the
functionality of the suite without requiring extra changes. Traditional
such as OpenVPN<span class="citation" data-cites="openVPNDocs">(OpenVPN
2022)</span> use a centralized service that all (encrypted) client
communications must pass through. This introduces a single point of
failure and a potential bottleneck that might negatively impact the
performance of the multi-party computations due to their nature.</p>
<figure>
<img src="notion/../figures/nat-intro.png"
title="Two parties behind separate NATs"
style="width:50.0%;height:25.0%"
alt="“Two parties behind separate NATs”" />
<figcaption aria-hidden="true">“Two parties behind separate
NATs”</figcaption>
</figure>
<p>On the other hand, mesh such as Tinc<span class="citation"
data-cites="tincDocs">(Sliepen 2022)</span>, Tailscale<span
class="citation" data-cites="tailscaleDocs">(Tailscale n.d.)</span> and
Nebula<span class="citation" data-cites="nebulaDocs">(Defined
2022)</span> utilize direct links between the clients for the data
traffic. Authentication, authorization and traffic encryption are
performed using certificates based on public key cryptography. As we
mentioned in the introduction chapter, the devices in a typical home
network can only initiate connections to public endpoints (via ) but
cannot be discovered from outside their . This poses a challenge when
two parties who want to communicate via a direct link are both behind
separate and neither can be contacted by the other one first. Mesh solve
this issue via traversal techniques such as hole punching based on
concepts from . The machines of each party can contact a public server ,
which will note what addresses the connections come from and inform the
parties. Since the parties initiated the connection to the STUN server,
their routers will keep a mapping between their local IP addresses and
the port that was allocated for the connection in order to be able to
forward the incoming traffic. Those “holes” in the NATs were originally
intended for the STUN server, but mesh VPNs use the stateless “fire and
forget” UDP protocol for their internal communication, which does not
require nor provides a mechanism for the NATs to verify who sent a UDP
packet. With most NATs, this is enough to be able to (ab)use the
“punched holes” for the purpose of traffic from other parties. Mesh VPNs
implement the stateful and protocols on top of UDP and expose an regular
network interface to the other programs, keeping them shielded from the
underlying complexities. Other NAT implementations such as Symmetric NAT
and can be more difficult to “punch through” due to their more complex
port mapping strategies. In those cases, establishing P2P connections
might involve guess work or even fail and require falling back to
routing the (encrypted) traffic via another party or service.</p>
<figure>
<img src="notion/../figures/nat-traversal.png"
title="NAT traversal via STUN" style="width:50.0%;height:25.0%"
alt="“NAT traversal via STUN”" />
<figcaption aria-hidden="true">“NAT traversal via STUN”</figcaption>
</figure>
<p>Now that we have a general understanding of how mesh VPNs work, let
us see how Tinc, Tailscale and Nebula compare. All three are
open-source, with the exception of Tailscale’s coordination service
which handles the peer discovery and identity management. Headscale
<span class="citation" data-cites="fontJuanfontHeadscale2022">(Font
[2020] 2022)</span> is a community driven open-source alternative for
that component. Tinc is the oldest of the three but has a relatively
small community. It is mainly developed by a single author and appears
to be more academic than industry motivated. Nebula and Tailscale are
both business driven. Tailscale was started by a number of high profile
ex-googlers and is the most end-user focused of the three, providing a
service that allows people to sign up using a variety of identity
providers including google, microsoft, github and others. They also
provide an Admin console that allows a user to easily add their personal
devices to a network or share them with others. It also has support for
automation tools like Terraform for creating authorization keys and
managing an based firewall. Nebula was originally developed at the
instant messaging company Slack to create overlay networks for their
cross region cloud infrastructure, but the authors later started a new
company and are currently developing a user-centric platform similar to
Tailscale’s. Nebula is more customizable than Tailscale and since it is
completely open-source it can be adapted to different use cases, but it
is also more involved to set up. A certificate authority needs to be
configured for issuing the identities of the participating hosts.
Furthermore, publicly accessible coordination servers need to be
deployed to facilitate the host discovery. Tailscale employs a
distributed relay network of servers, while Nebula can be configured to
route via one of the other peers in the VPN.</p>
<p>We decided to use Tailscale for the initial implementation of because
it has all the necessary features to support networked MPC while also
being the easiest one to set up as it does not require any extra
services to be deployed.</p>
<p>We will now briefly mention some additional approaches we looked into
that may be a good starting point for the next phase of the project.</p>
<h3 data-number="2.2.2"
id="decentralized-identifiers-dids-and-didcomm"><span
class="header-section-number">2.2.2</span> Decentralized Identifiers
(DIDs) and DIDComm</h3>
<p> is a way of managing a digital identity that emphasises an
individual’s ownerhip and control over their personal data. In contrast
with more traditional methods, SSI does not rely on a third party such
as a government or an organization to issue identities - people issue
their own identities, usually in the form of an asymmetric key-pair.
<span class="citation" data-cites="didW3C">(Sporny et al. 2022)</span>
are a form of that recently reached W3C Recommendation Status and
DIDComm<span class="citation" data-cites="didcommSpec">(Foundation
2022)</span> is a set of communication protocols based on DIDs. Its main
design goals are to be private, secure, decentralized, transport
agnostic and routable. Its primary concerns are with the message
formats, cryptograhic algorithms and processes that enable identity
owners to find each other and interact digitally based on their
identities rather than TCP concepts like IP addresses. One thing we
noticed was that the initial version of DIDComm does not support
stateful sessions and therefore all messages need to be both encrypted
with the recepient’s public key and signed by the sender’s private key.
This will likely cause performance issues in the MPC setting because it
usually involves a large number of small messages containing the secret
shares of the parties. In order for DIDComm to be usable for MPyC we
would likely have to implement a TLS-like protocol on top of it that
supports sessions.</p>
<h3 data-number="2.2.3" id="the-onion-router-tor"><span
class="header-section-number">2.2.3</span> The Onion Router (TOR)</h3>
<p>Two machines need to know each other’s IP addresses in order to be
able to interact via the internet. An IP address can reveal details
about a person’s location or be used to launch a attack against them.
Additionally, nearby attackers could be listening to their traffic and
tracking their internet behaviour, which may be undesirable depending on
a person’s privacy requirements. TOR uses a network of relays to
obfuscate the communication route between two parties. The original
sender prepares a multi-layered message, where each layer is encrypted
for a specific relayer. When one of them receives a message, they only
know who was the previous link and after decrypting their part of the
message, they know the next link. They do not know who was the original
sender and who is the final destination. The privacy comes at the cost
of performance. Additionally, TOR has the concept of Onion Services,
which receive an address under the .onion pseudo top level domain and
correspond to a public key
(e.g. vww6ybal4bd7szmgncyruucpgfkqahzddi37ktceo3ah7ngmcopnpyyd.onion).
It allows two way privacy preserving communications. A concept similar
to TOR can be optionally incorporated in MPyC for the cases when privacy
is essential. It is interesting to measure the performance impact on
MPyC computations when routed via a TOR-like relay network.</p>
<h2 data-number="2.3" id="summary"><span
class="header-section-number">2.3</span> Summary</h2>
<p>In this chapter we compared a number of potential building blocks for
and made some choices informed by our requirements. Specifically, we
will use Terraform for provisioning Virtual Machines running NixOS on
DigitalOcean and Colmena for deploying to them. Our initial
implementation will use Tailscale as the connectivity layer due to its
ease of use. In the next phase of the project, we plan to explore
solutions based on Nebula, DIDComm, TOR and combinations of the
above.</p>
<h1 data-number="3" id="implementation-details"><span
class="header-section-number">3</span> Implementation details</h1>
<p>In this chapter we will cover the implementation of , which can be
found on <a href="https://github.com/e-nikolov/mpyc">Github</a>. It is a
fork of <a href="https://github.com/lschoe/mpyc">MPyC</a> that adds
deployment capabilities. We will now discuss the more critical parts of
the implementation.</p>
<h2 data-number="3.1" id="reproducible-development-of-mpyc"><span
class="header-section-number">3.1</span> Reproducible development of
MPyC</h2>
<p>As previously discussed, the of run the NixOS distribution of Linux,
which is based on the declarative package manager Nix. One of its
benefits is that it can also be used to declaratively manage the
dependencies of a software project via its development shells feature.
Normally such a project would have to explain in its readme how to
install and configure all of the extra tools that are needed for working
with it. On the other hand, with Nix, we can run the command
<code>nix develop</code> in a directory containing a declarative
specification in a flake.nix file. This will open a temporary shell
environment and install the specified versions of the dependencies.
Exiting the shell will uninstall them. This process makes it easy to
work on projects that require conflicting versions of packages. To
achieve this, nix does the following:</p>
<ul>
<li>it places each build result under <code>/nix/store/</code>, in a
sub-directory prefixed by the hash of its inputs,
e.g. <code>/nix/store/2ispfz80kmwrsvwndxkxs56irn86h43p-bash-5.1-p16/</code></li>
<li>nix opens a new shell with a modified <code>PATH</code> environment
variable that includes the nix store path that contains the new
package.</li>
</ul>
<p>There are tools like nix-direnv that take dev shells a step further
by automatically loading/unloading the specified dependencies when
entering/leaving a directory that contains a dev shell
specification.</p>
<p>The entrypoint for Nix in our MPyC fork is the <a
href="https://github.com/e-nikolov/mpyc/blob/master/flake.nix">flake.nix</a>
file. A simplified version can be seen below:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">description</span> <span class="op">=</span> <span class="st">&quot;MPyC flake&quot;</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">inputs</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">nixpkgs</span>.<span class="va">url</span> <span class="op">=</span> <span class="st">&quot;github:nixos/nixpkgs/nixos-unstable&quot;</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="va">outputs</span> <span class="op">=</span> inputs@<span class="op">{</span> <span class="va">self</span><span class="op">,</span> <span class="va">nixpkgs</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span>:</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      <span class="co"># import the derivation of mpyc and all of its python dependencies</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>      <span class="va">mpyc-demo</span> <span class="op">=</span> <span class="op">(</span><span class="bu">import</span> <span class="ss">./nix/mpyc-demo.nix</span> <span class="op">{</span> <span class="kw">inherit</span> pkgs<span class="op">;</span> <span class="va">dir</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span> <span class="op">});</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>      <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> nixpkgs <span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">system</span> <span class="op">=</span> <span class="st">&quot;x86_64-linux&quot;</span><span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>      <span class="va">devShell</span>.<span class="va">x86_64-linux</span> <span class="op">=</span> pkgs.mkShell <span class="op">{</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">shellHook</span> <span class="op">=</span> <span class="st">&#39;&#39;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="st">          export PYTHONPATH=./</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="st">        &#39;&#39;</span><span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">nativeBuildInputs</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>          pkgs.curl pkgs.jq</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>          pkgs.colmena pkgs.pssh</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>          <span class="op">(</span>pkgs.terraform.withPlugins</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span><span class="va">tp</span><span class="op">:</span> <span class="op">[</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>              tp.digitalocean tp.<span class="cn">null</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>              tp.external tp.tailscale</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>              tp.random</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">]))</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>          mpyc-demo</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">];</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The flake is functionally pure in the sense that all external inputs
are explicitly declared in the inputs section and their hashes are kept
in a <code>flake.lock</code> file. In our example, the only input is
<code>nixpkgs</code> - a community managed repository containing the nix
build expressions for more than 80 000 packages. When a nix command uses
the file for the first time, the latest revision of the nixos-unstable
branch of the git repository will be fetched and its contents will be
hashed and placed in the flake.lock. Further executions will reuse the
revision from the lock file and verify that the resulting hash matches
the original one. The lock file can be updated via the
<code>nix flake update</code> command. The output section contains the
<code>devShell.x86_64-linux</code> attribute which declares the packages
required to work with the project. Specifically, it needs the nix
packages for curl, jq, colmena, pssh and terraform with a number of
plugins. Finally it also builds the <code>mpyc-demo</code> package which
contains python and all python dependencies needed by MPyC. Its
specification is imported from the <code>mpyc-demo.nix</code> file:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">pkgs</span><span class="op">,</span> <span class="va">dir</span> <span class="op">}</span>:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>pkgs.poetry2nix.mkPoetryEnv <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">python</span> <span class="op">=</span> pkgs.python3<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">projectDir</span> <span class="op">=</span> dir<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">extraPackages</span> <span class="op">=</span> <span class="op">(</span><span class="va">ps</span><span class="op">:</span> <span class="op">[</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span>pkgs.python3Packages.buildPythonPackage</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>          <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;mpyc&quot;</span><span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>          <span class="va">src</span> <span class="op">=</span> dir<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">})</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">]);</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="va">overrides</span> <span class="op">=</span> pkgs.poetry2nix.overrides.withDefaults <span class="op">(</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span><span class="op">:</span> <span class="va">super</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">gmpy2</span> <span class="op">=</span> pkgs.python3Packages.gmpy2<span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">})</span></span></code></pre></div>
<p>MPyC uses the python specific dependency management tool poetry<span
class="citation" data-cites="poetryDocs">(Poetry 2022)</span> and the
poetry2nix package dynamically generates nix expressions from its
configuration in <code>pyproject.toml</code></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">tool</span><span class="kw">.</span><span class="dt">poetry</span><span class="kw">]</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">name</span> <span class="op">=</span> <span class="st">&quot;mpyc&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">version</span> <span class="op">=</span> <span class="st">&quot;0.8.8&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dt">description</span> <span class="op">=</span> <span class="st">&quot;MPyC for Multiparty Computation in Python&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="dt">authors</span> <span class="op">=</span> <span class="op">[</span><span class="st">&quot;Berry Schoenmakers &lt;berry@win.tue.nl&gt;&quot;</span><span class="op">]</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dt">readme</span> <span class="op">=</span> <span class="st">&quot;README.md&quot;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="dt">packages</span> <span class="op">=</span> <span class="op">[{</span><span class="dt">include</span><span class="op"> =</span> <span class="st">&quot;demos&quot;</span><span class="op">}]</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">tool</span><span class="kw">.</span><span class="dt">poetry</span><span class="kw">.</span><span class="dt">dependencies</span><span class="kw">]</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="dt">python</span> <span class="op">=</span> <span class="st">&quot;^3.10&quot;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="dt">qrcode</span> <span class="op">=</span> <span class="st">&quot;^7.3.1&quot;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="dt">numpy</span> <span class="op">=</span> <span class="st">&quot;^1.23.4&quot;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="dt">gmpy2</span> <span class="op">=</span> <span class="st">&quot;^2.1.2&quot;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">build-system</span><span class="kw">]</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="dt">requires</span> <span class="op">=</span> <span class="op">[</span><span class="st">&quot;poetry-core&quot;</span><span class="op">]</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="dt">build-backend</span> <span class="op">=</span> <span class="st">&quot;poetry.core.masonry.api&quot;</span></span></code></pre></div>
<p>There was an issue with the gmpy2 library when building it via
poetry2nix, but fortunately we could override it with the version
already present in nixpkgs.</p>
<p>Using this setup we can now go to the root directory of MPyC and run
the <code>nix develop</code> command, which will automatically download,
build and install all of our dependencies in a temporary shell. We are
then ready to make changes to MPyC or locally run the demos, e.g. via
<code>python ./demos/secretsanta.py</code>. ## Building a NixOS image
for DigitalOcean As previously discussed we will deploy on DigitalOcean
droplets - their name for . They do not provide an official NixOS image,
but we can build our own using nix.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">## flake.nix</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">inputs</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">nixpkgs</span>.<span class="va">url</span> <span class="op">=</span> <span class="st">&quot;github:nixos/nixpkgs/nixos-unstable&quot;</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="va">outputs</span> <span class="op">=</span> inputs@<span class="op">{</span> <span class="va">self</span><span class="op">,</span> <span class="va">nixpkgs</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span>:</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>      <span class="va">mpyc-demo</span> <span class="op">=</span> <span class="op">(</span><span class="bu">import</span> <span class="ss">./nix/mpyc-demo.nix</span> <span class="op">{</span> <span class="kw">inherit</span> pkgs<span class="op">;</span> <span class="va">dir</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span> <span class="op">});</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>      <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> nixpkgs <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">system</span> <span class="op">=</span> <span class="st">&quot;x86_64-linux&quot;</span><span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>      <span class="va">digitalOceanConfig</span> <span class="op">=</span> <span class="bu">import</span> <span class="ss">./nix/digitalocean/image.nix</span> <span class="op">{</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">inherit</span> pkgs<span class="op">;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">extraPackages</span> <span class="op">=</span> <span class="op">[</span> mpyc-demo <span class="op">];</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">packages</span>.<span class="va">digitalOceanImage</span> <span class="op">=</span> <span class="op">(</span>pkgs.nixos digitalOceanConfig<span class="op">)</span>.digitalOceanImage<span class="op">;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb5"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">## nix/digitalocean/image.nix</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">pkgs</span><span class="op">,</span> <span class="va">extraPackages</span> <span class="op">?</span> <span class="op">[</span> <span class="op">],</span> <span class="op">...</span> <span class="op">}</span>:</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">imports</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;</span><span class="sc">${</span>pkgs.path<span class="sc">}</span><span class="st">/nixos/modules/virtualisation/digital-ocean-image.nix&quot;</span> <span class="op">];</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="va">system</span>.<span class="va">stateVersion</span> <span class="op">=</span> <span class="st">&quot;22.11&quot;</span><span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="va">environment</span>.<span class="va">systemPackages</span> <span class="op">=</span> <span class="kw">with</span> pkgs<span class="op">;</span> <span class="op">[</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    jq</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">]</span> <span class="op">++</span> extraPackages<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  <span class="va">services</span>.<span class="va">tailscale</span>.<span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span class="va">networking</span>.<span class="va">firewall</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="va">checkReversePath</span> <span class="op">=</span> <span class="st">&quot;loose&quot;</span><span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="va">trustedInterfaces</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;tailscale0&quot;</span> <span class="op">];</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The image is based on the default version provided by nixpkgs and
adds some extra packages and configurations. It:</p>
<ul>
<li>enables the tailscale service so that we can easily configure them
to join the same tailscale network;</li>
<li>configures the firewall to allow tailscale traffic;</li>
<li>includes the <code>mpyc-demo</code> package we made earlier for the
development shell.</li>
</ul>
<p>The image will likely be built only once, but it is still useful to
have even an outdated version of the demo baked into it as it helps us
avoid having to build all of the python dependencies while deploying
later.</p>
<p>Running <code>nix build .#packages.digitalOceanImage</code> creates a
<code>.qcow2.gz</code> formatted image file that can be imported into
DigitalOcean.</p>
<h2 data-number="3.2" id="building-a-nixos-image-for-raspberrypi"><span
class="header-section-number">3.2</span> Building a NixOS image for
RaspberryPi</h2>
<p>We can build a NixOS image for a RaspberryPi4 with a similar nix
expression:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">inputs</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">nixpkgs</span>.<span class="va">url</span> <span class="op">=</span> <span class="st">&quot;github:nixos/nixpkgs/nixos-unstable&quot;</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="va">outputs</span> <span class="op">=</span> inputs@<span class="op">{</span> <span class="va">self</span><span class="op">,</span> <span class="va">nixpkgs</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span>:</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>      <span class="va">mpyc-demo</span> <span class="op">=</span> <span class="op">(</span><span class="bu">import</span> <span class="ss">./nix/mpyc-demo.nix</span> <span class="op">{</span> <span class="kw">inherit</span> pkgs<span class="op">;</span> <span class="va">dir</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span> <span class="op">});</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>      <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> nixpkgs <span class="op">{</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">system</span> <span class="op">=</span> <span class="st">&quot;aarch64-linux&quot;</span><span class="op">;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">packages</span>.<span class="va">raspberryPi4Image</span> <span class="op">=</span> <span class="op">(</span>pkgs.nixos <span class="op">({</span> <span class="va">config</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            <span class="va">system</span>.<span class="va">stateVersion</span> <span class="op">=</span> <span class="st">&quot;22.11&quot;</span><span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>            <span class="va">imports</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>              <span class="op">(</span><span class="st">&quot;</span><span class="sc">${</span>pkgs.path<span class="sc">}</span><span class="st">/nixos/modules/installer/sd-card/sd-image-aarch64-installer.nix&quot;</span><span class="op">)</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">];</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>            <span class="va">environment</span>.<span class="va">systemPackages</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>                mpyc-demo</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">];</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}))</span>.sdImage<span class="op">;</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The build command has to be executed on an ARM64 based processor in
order to succeed. This can be achieved either via emulation with qemu
binfmt or via a virtual machine. When already running NixOS as a host,
all that is required is to add
<code>extra-platforms = aarch64-linux</code> to the
<code>/etc/nixos/nix.conf</code> file. ## Provisioning via Terraform We
will provision DigitalOcean droplets with Terraform from the VM image
created earlier. We need to provide it with a DigitalOcean authorization
key in the <code>DIGITALOCEAN_TOKEN</code> environment variable so it
can use their API on our behalf.</p>
<h4 data-number="3.2.0.1" id="importing-the-image"><span
class="header-section-number">3.2.0.1</span> Importing the image</h4>
<p>The snippet below handles the upload of our NixOS image.</p>
<pre class="terraform"><code>variable &quot;nixos-image-path&quot; {
  type    = string
  default = &quot;../../bin/image/nixos.qcow2.gz&quot;
}

resource &quot;digitalocean_spaces_bucket&quot; &quot;tf-state&quot; {
  name   = &quot;mpyc-tf-state&quot;
  region = &quot;ams3&quot;

  lifecycle {
    prevent_destroy = true
  }
}

resource &quot;digitalocean_spaces_bucket_object&quot; &quot;nixos-image&quot; {
  region = digitalocean_spaces_bucket.tf-state.region
  bucket = digitalocean_spaces_bucket.tf-state.name
  key    = basename(var.nixos-image-path)
  source = var.nixos-image-path
  acl    = &quot;public-read&quot;
  etag   = filemd5(var.nixos-image-path)
}

resource &quot;digitalocean_custom_image&quot; &quot;nixos-image&quot; {
  name    = &quot;nixos-22.11&quot;
  url     = &quot;https://${digitalocean_spaces_bucket.tf-state.bucket_domain_name}/${digitalocean_spaces_bucket_object.nixos-image.key}&quot;
  regions = local.all_regions
  tags    = [&quot;nixos&quot;]

  lifecycle {
    replace_triggered_by = [
      digitalocean_spaces_bucket_object.nixos-image
    ]
  }
}</code></pre>
<p>The DigitalOcean API only supports importing images from a URL, so we
first need to upload the image to a publicly accessible location. For
that purpose, the snippet above first provisions a Bucket within Spaces
- DigitalOcean’s cloud storage solution and uploads the image there.
After that, the <code>digitalocean_custom_image</code> will import the
image from the URL generated by the bucket.</p>
<h4 data-number="3.2.0.2" id="generating-hostnames"><span
class="header-section-number">3.2.0.2</span> Generating hostnames</h4>
<p>The snippet below starts with a specification of how many machines
per region we want to have and transforms it into a list of descriptive
ids (e.g. <code>mpyc-demo--ams3-0-15e53f39</code>) that will be used as
host names so we can easily distinguish the machines when they start
communicating with each other.</p>
<pre class="terraform"><code>locals {
  node_definitions = var.DESTROY_NODES != &quot;&quot; ? [
    { region = &quot;ams3&quot;, num = 0 },
    { region = &quot;sfo3&quot;, num = 0 },
    { region = &quot;nyc3&quot;, num = 0 },
    { region = &quot;sgp1&quot;, num = 0 },
    ] : [
    { region = &quot;ams3&quot;, num = 3 },
    { region = &quot;sfo3&quot;, num = 1 },
    { region = &quot;nyc3&quot;, num = 1 },
    { region = &quot;sgp1&quot;, num = 1 },
  ]

  nodes_expanded = flatten([
    for node in local.node_definitions : [
      for i in range(node.num) :
      merge(node, {
        name = &quot;mpyc-demo--${node.region}-${i}&quot;
      })
    ]
  ])

  nodes = {
    for node in local.nodes_expanded :
    node.name =&gt; merge(node, {
      hostname = &quot;${node.name}-${random_id.mpyc-node-hostname[node.name].hex}&quot;
    })
  }
}</code></pre>
<h4 data-number="3.2.0.3" id="provisioning-the-hosts"><span
class="header-section-number">3.2.0.3</span> Provisioning the hosts</h4>
<p>The snippet below provisions the droplets in the specified regions
and then using Tailscale’s terraform provider creates auth keys for the
machines, copies them to the machines and configures them to join the
tailscale network. When the droplets are being destroyed, the
provisioner will remove the nodes from the network.</p>
<pre class="terraform"><code>resource &quot;digitalocean_droplet&quot; &quot;mpyc-node&quot; {
  for_each = local.nodes

  image    = digitalocean_custom_image.nixos-image.id
  name     = each.value.hostname
  region   = each.value.region
  size     = &quot;s-1vcpu-1gb&quot;
  ssh_keys = [for key in digitalocean_ssh_key.ssh-keys : key.fingerprint]

  connection {
    type = &quot;ssh&quot;
    user = &quot;root&quot;
    host = self.ipv4_address
  }

  provisioner &quot;remote-exec&quot; {
    inline = [
      &quot;mkdir -p /var/keys/&quot;,
      &quot;echo ${tailscale_tailnet_key.keys.key} &gt; /var/keys/tailscale&quot;,
      &quot;tailscale up --auth-key file:/var/keys/tailscale&quot;
    ]
  }

  provisioner &quot;remote-exec&quot; {
    when = destroy
    inline = [
      &quot;tailscale logout&quot;
    ]
  }

  lifecycle {
    replace_triggered_by = [
      tailscale_tailnet_key.keys
    ]
  }
}

resource &quot;tailscale_tailnet_key&quot; &quot;keys&quot; {
  reusable      = true
  ephemeral     = true
  preauthorized = true
}</code></pre>
<h4 data-number="3.2.0.4" id="interfacing-with-other-tools"><span
class="header-section-number">3.2.0.4</span> Interfacing with other
tools</h4>
<p>This snippet outputs the hostnames of the provisioned droplets so
they can be picked up by other tools. For example Colmena will read them
from a json file so it can deploy further software changes to them.</p>
<pre class="terraform"><code>

output &quot;hosts-colmena&quot; {
  value = { for node in local.nodes : node.hostname =&gt; {} }
}

output &quot;hosts-pssh&quot; {
  value = join(&quot;&quot;, [for node in local.nodes : &quot;root@${node.hostname}\n&quot;])
}
</code></pre>
<h2 data-number="3.3" id="colmena-deployment"><span
class="header-section-number">3.3</span> Colmena deployment</h2>
<p>Whenever we need to update the NixOS configuration of our VMs, we
could rebuild the image and re-provision them, but this would be slow.
Instead we use Colmena to deploy and apply the new configuration to all
existing VMs. It uses the same <code>digitalOceanConfig</code> attribute
we created for the NixOS image:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">inputs</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">nixpkgs</span>.<span class="va">url</span> <span class="op">=</span> <span class="st">&quot;github:nixos/nixpkgs/nixos-unstable&quot;</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="va">outputs</span> <span class="op">=</span> inputs@<span class="op">{</span> <span class="va">self</span><span class="op">,</span> <span class="va">nixpkgs</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span>:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>      <span class="va">mpyc-demo</span> <span class="op">=</span> <span class="op">(</span><span class="bu">import</span> <span class="ss">./nix/mpyc-demo.nix</span> <span class="op">{</span> <span class="kw">inherit</span> pkgs<span class="op">;</span> <span class="va">dir</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span> <span class="op">});</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>      <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> nixpkgs <span class="op">{</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">system</span> <span class="op">=</span> <span class="st">&quot;x86_64-linux&quot;</span><span class="op">;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>      <span class="va">digitalOceanConfig</span> <span class="op">=</span> <span class="bu">import</span> <span class="ss">./nix/digitalocean/image.nix</span> <span class="op">{</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">inherit</span> pkgs<span class="op">;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">extraPackages</span> <span class="op">=</span> <span class="op">[</span> mpyc-demo <span class="op">];</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>      <span class="va">packages</span>.<span class="va">colmena</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">meta</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>          <span class="va">nixpkgs</span> <span class="op">=</span> pkgs<span class="op">;</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">defaults</span> <span class="op">=</span> digitalOceanConfig<span class="op">;</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="op">//</span> <span class="bu">builtins</span>.fromJSON <span class="op">(</span><span class="bu">builtins</span>.readFile <span class="ss">./hosts.json</span><span class="op">);</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This allows us to quickly make changes to the NixOS configuration,
deploy it via Colmena and once we are satisfied with it, we can choose
to rebuild the image so that new machines get provisioned with all of
our changes baked in.</p>
<h2 data-number="3.4" id="runtime-execution"><span
class="header-section-number">3.4</span> Runtime execution</h2>
<p>We have identified the tools we will use to deploy and how the host
machines will communicate. What remains is to determine how to run a
joint computation on the hosts. When running such an experiment, it
would be desirable to be able to iterate quickly. Colmena can be used to
deploy a new version of the whole operating system, but it would be
unnecessary to rebuild all dependencies every time we want to run a
command. Therefore we decided to use two additional tools:</p>
<ul>
<li><em>prsync</em> - a variant of the popular <em>rsync</em> utility
that can additively sync the contents of a directory to multiple remote
hosts</li>
<li><em>pssh</em> - a tool for executing an ssh command on many hosts in
parallel</li>
</ul>
<p>An example execution looks like this:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">prsync</span> <span class="at">-h</span> hosts.pssh <span class="at">-zarv</span> <span class="at">-p</span> 4 ./ /root/mpyc</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ex">pssh</span> <span class="at">-h</span> hosts.pssh <span class="at">-iv</span> <span class="at">-o</span> ./logs/<span class="va">$t</span> <span class="st">&quot;cd /root/mpyc &amp;&amp; ./prun.sh&quot;</span></span></code></pre></div>
<p>It loads the hostnames from the <code>hosts.pssh</code> file that was
previously generated by terraform and syncs the current state of the
mpyc directory. The second line will execute the <code>prun.sh</code>
script on each host.</p>
<p>An example of a possible <code>prun.sh</code> script:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/sh</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="va">MAX_PARTIES</span><span class="op">=</span>600</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="va">hosts</span><span class="op">=</span><span class="st">&quot;./hosts.pssh&quot;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="va">port</span><span class="op">=</span>11599</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="va">i</span><span class="op">=</span>0</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="va">MY_PID</span><span class="op">=</span>-1</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="va">args</span><span class="op">=</span><span class="st">&quot;&quot;</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="va">IFS</span><span class="op">=</span> <span class="bu">read</span> <span class="at">-r</span> <span class="va">line</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">[</span> <span class="va">$i</span> <span class="ot">-ge</span> <span class="va">$MAX_PARTIES</span> <span class="bu">]</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">then</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">fi</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">[</span> <span class="ot">-z</span> <span class="st">&quot;</span><span class="va">$line</span><span class="st">&quot;</span> <span class="bu">]</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">then</span> </span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">fi</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    <span class="va">host</span><span class="op">=</span><span class="va">${line</span><span class="op">#</span><span class="st">&quot;root@&quot;</span><span class="va">}</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">[</span> <span class="st">&quot;</span><span class="va">$host</span><span class="st">&quot;</span> <span class="ot">=</span> <span class="st">&quot;</span><span class="va">$HOSTNAME</span><span class="st">&quot;</span> <span class="bu">]</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">then</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">MY_PID</span><span class="op">=</span><span class="va">$i</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">fi</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">((</span><span class="va">i</span> <span class="op">=</span> <span class="va">i</span> <span class="op">+</span> <span class="dv">1</span><span class="kw">))</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    <span class="va">args</span><span class="op">+=</span><span class="st">&quot; -P </span><span class="va">$host</span><span class="st">:</span><span class="va">$port</span><span class="st">&quot;</span> </span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a><span class="cf">done</span> <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$hosts</span><span class="st">&quot;</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="va">$MY_PID</span> <span class="ot">=</span> -1 <span class="bu">]</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a><span class="cf">then</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> Only <span class="va">$i</span> parties are allowed. <span class="va">$HOSTNAME</span> will not participate in this MPC session</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a><span class="va">cmd</span><span class="op">=</span><span class="st">&quot;python ./demos/secretsanta.py 3 --log-level debug </span><span class="dt">\</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a><span class="st">    -I </span><span class="va">${MY_PID}</span><span class="st"> </span><span class="dt">\</span></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a><span class="st">    </span><span class="va">${args}</span><span class="st">&quot;</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="va">$cmd</span></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a><span class="va">$cmd</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span></code></pre></div>
<p>Each host runs the same script that builds the arguments for the
<code>secretsanta.py</code> demo of MPyC. Each party determines its own
Party ID based on the index at which its hostname appears in the
<code>hosts.pssh</code> file.</p>
<h2 data-number="3.5" id="secrets"><span
class="header-section-number">3.5</span> Secrets</h2>
<p>The implementation expects that secrets are supplied as environment
variables with the specific mechanism being left up to the user. We are
currently keeping the secret values in the 1Password manager and use its
to populate the environment variables at runtime, e.g. via
<code>op run -- make deploy</code>.</p>
<h1 data-number="4" id="conclusions"><span
class="header-section-number">4</span> Conclusions</h1>
<p>In this report we presented the results of the preparation phase for
the master thesis assignment “Secure Sessions for Ad Hoc Multiparty
Computation in MPyC”. We developed an for the purpose of creating ad hoc
networks of host machines that perform in hybrid scenarios involving
both cloud and physical machines. makes extensive use of declarative
tools in order to achieve highly reproducible deployments in an
automated way. We provided a reference implementation that makes use of
the Tailscale mesh VPN that creates a network of RaspberryPis and cloud
on DigitalOcean. The cloud provisioning is defined declaratively using
Terraform and allows to define a set of host machines across the regions
supported by DigitalOcean (e.g. Amsterdam, New York City, etc) and
automatically add them to a shared Tailscale network. The machines run
NixOS - a declarative and highly reproducible Linux distribution while
Colmena is used to declaratively manage the software installed on them
via . The tools <code>prsync</code> and <code>pssh</code> are used to
run MPyC demos in parallel on the deployed hosts.</p>
<h4 data-number="4.0.0.1" id="implementation-phase-planning"><span
class="header-section-number">4.0.0.1</span> Implementation phase
planning</h4>
<p>During the next phase of the thesis assignment, we plan to implement
various connectivity approaches for ’s host machines and analyse their
suitability for MPyC.</p>
<p>The following is a list of high level tasks that we plan to carry out
as part of the implementation phase:</p>
<ul>
<li>replace the proprietary Tailscale coordination service from our
reference implementation of with the open-source self-hosted alternative
Headscale<span class="citation"
data-cites="fontJuanfontHeadscale2022">(Font [2020] 2022)</span></li>
<li>develop a network overlay for based on the Nebula mesh VPN. Nebula
only provides a way to manually perform the initial setup, so our
implementation should add a way to automatically:
<ul>
<li>allocate virtual IP addresses for the hosts</li>
<li>generate identity certificates using the Nebula </li>
<li>distribute the certificates among the hosts</li>
</ul></li>
<li>develop network overlays for that incorporate parts of the mesh VPN
implementations but with alternative identity management approaches:
<ul>
<li>using a that is managed jointly using MPC</li>
<li>using a form of such as </li>
</ul></li>
<li>implement a network overlay for based on DIDComm</li>
<li>explore options for enhancing the DIDComm implementation to:
<ul>
<li>support sessions - the DIDComm protocol is currently stateless and
uses a new asymmetric key for each message, which negatively impacts
performance</li>
<li>employ traversal techniques similar to mesh </li>
</ul></li>
<li>implement a privacy mechanism for based on in order to prevent
leaking sensitive information like which parties are communicating with
each other and their IP addresses</li>
<li>investigate if we can apply ideas from the implementations in other
software like the Ethereum[<span class="citation"
data-cites="ethereumDocs">Ethereum (now)</span>]<span class="citation"
data-cites="ethereumYellowPaper">(Wood 2022)</span> blockchain and the
<span class="citation" data-cites="ipfsDocs">(IPFS n.d.)</span></li>
<li>analyse and compare all of the above implementations in terms of:
<ul>
<li>security</li>
<li>performance</li>
<li>ease of use</li>
<li>privacy</li>
</ul></li>
<li>compare to other work related to deploying MPC such as the Carbyne
stack<span class="citation"
data-cites="robertboschgmbhCarbyneStack2022">(GmbH [2021]
2022)</span></li>
</ul>
<div id="refs" class="references csl-bib-body hanging-indent"
role="doc-bibliography">
<div id="ref-cfDocs" class="csl-entry" role="doc-biblioentry">
AWS. 2022. <span>“<span>AWS CloudFormation Documentation</span>.”</span>
2022. <a
href="https://docs.aws.amazon.com/cloudformation">https://docs.aws.amazon.com/cloudformation</a>.
</div>
<div id="ref-biasHistoryPetsVs2016" class="csl-entry"
role="doc-biblioentry">
Bias, Randy. 2016. <span>“The <span>History</span> of <span>Pets</span>
Vs <span>Cattle</span> and <span>How</span> to <span>Use</span> the
<span>Analogy Properly</span>.”</span> <span>Cloudscaling</span>.
September 29, 2016. <a
href="http://cloudscaling.com/blog/cloud-computing/the-history-of-pets-vs-cattle/">http://cloudscaling.com/blog/cloud-computing/the-history-of-pets-vs-cattle/</a>.
</div>
<div id="ref-morphSource" class="csl-entry" role="doc-biblioentry">
BiblioteksCenter, Dansk. (2018) 2022. <em>Morph</em>. <span>DBC</span>.
<a
href="https://github.com/DBCDK/morph">https://github.com/DBCDK/morph</a>.
</div>
<div id="ref-chefDocs" class="csl-entry" role="doc-biblioentry">
Chef. 2022. <span>“Chef <span>Documentation</span>.”</span> 2022. <a
href="https://docs.chef.io/">https://docs.chef.io/</a>.
</div>
<div id="ref-nebulaDocs" class="csl-entry" role="doc-biblioentry">
Defined. 2022. <span>“Nebula: <span>Open Source Overlay
Networking</span> | <span>Nebula Docs</span>.”</span> 2022. <a
href="https://docs.defined.net/docs/">https://docs.defined.net/docs/</a>.
</div>
<div id="ref-dockerDocs" class="csl-entry" role="doc-biblioentry">
Docker. 2022. <span>“Swarm Mode Overview.”</span> <span>Docker
Documentation</span>. November 25, 2022. <a
href="https://docs.docker.com/engine/swarm/">https://docs.docker.com/engine/swarm/</a>.
</div>
<div id="ref-ethereumDocs" class="csl-entry" role="doc-biblioentry">
Ethereum. now. <span>“Ethereum Development Documentation |
Ethereum.org.”</span> now. <a
href="https://ethereum.org/en/developers/docs/">https://ethereum.org/en/developers/docs/</a>.
</div>
<div id="ref-fontJuanfontHeadscale2022" class="csl-entry"
role="doc-biblioentry">
Font, Juan. (2020) 2022. <em>Juanfont/Headscale</em>. <a
href="https://github.com/juanfont/headscale">https://github.com/juanfont/headscale</a>.
</div>
<div id="ref-didcommSpec" class="csl-entry" role="doc-biblioentry">
Foundation, Digital Identity. 2022. <span>“<span>DIDComm Messaging
Specification</span> V2 <span>Editor</span>’s
<span>Draft</span>.”</span> 2022. <a
href="https://identity.foundation/didcomm-messaging/spec/">https://identity.foundation/didcomm-messaging/spec/</a>.
</div>
<div id="ref-robertboschgmbhCarbyneStack2022" class="csl-entry"
role="doc-biblioentry">
GmbH, Robert Bosch. (2021) 2022. <em>Carbyne <span>Stack</span></em>.
<span>Carbyne Stack</span>. <a
href="https://github.com/carbynestack/carbynestack">https://github.com/carbynestack/carbynestack</a>.
</div>
<div id="ref-tfDocs" class="csl-entry" role="doc-biblioentry">
Hashicorp. 2022. <span>“Terraform <span>Documentation</span>.”</span>
<span>Terraform | HashiCorp Developer</span>. 2022. <a
href="https://developer.hashicorp.com/terraform">https://developer.hashicorp.com/terraform</a>.
</div>
<div id="ref-ipfsDocs" class="csl-entry" role="doc-biblioentry">
IPFS. n.d. <span>“<span>IPFS Documentation</span> | <span>IPFS
Docs</span>.”</span> Accessed December 10, 2022. <a
href="https://docs.ipfs.tech/">https://docs.ipfs.tech/</a>.
</div>
<div id="ref-knottCrypTenSecureMultiParty2022" class="csl-entry"
role="doc-biblioentry">
Knott, Brian, Shobha Venkataraman, Awni Hannun, Shubho Sengupta, Mark
Ibrahim, and Laurens van der Maaten. 2022. <span>“<span>CrypTen</span>:
<span>Secure Multi-Party Computation Meets Machine
Learning</span>.”</span> <span>arXiv</span>. <a
href="https://doi.org/10.48550/arXiv.2109.00984">https://doi.org/10.48550/arXiv.2109.00984</a>.
</div>
<div id="ref-kubeDocs" class="csl-entry" role="doc-biblioentry">
Kubernetes. 2022. <span>“Kubernetes <span>Documentation</span>.”</span>
<span>Kubernetes</span>. 2022. <a
href="https://kubernetes.io/docs/home/">https://kubernetes.io/docs/home/</a>.
</div>
<div id="ref-laudApplicationsSecureMultiparty2015" class="csl-entry"
role="doc-biblioentry">
Laud, Peeter, and Liina Kamm, eds. 2015. <em>Applications of Secure
Multiparty Computation</em>. Cryptology and Information Security Series,
volume 13. <span>Amsterdam, Netherlands</span>: <span>Ios Press</span>.
</div>
<div id="ref-colmenaDocs" class="csl-entry" role="doc-biblioentry">
Li, Zhaofeng. 2022. <span>“Reference - <span>Colmena</span>
(<span>Unstable</span>).”</span> 2022. <a
href="https://colmena.cli.rs/unstable/reference/">https://colmena.cli.rs/unstable/reference/</a>.
</div>
<div id="ref-colmenaSource" class="csl-entry" role="doc-biblioentry">
———. (2020) 2022. <em>Colmena</em>. <a
href="https://github.com/zhaofengli/colmena">https://github.com/zhaofengli/colmena</a>.
</div>
<div id="ref-nixopsDocs" class="csl-entry" role="doc-biblioentry">
NixOps. 2022. <span>“<span>NixOps User</span>’s
<span>Guide</span>.”</span> 2022. <a
href="https://hydra.nixos.org/build/115931128/download/1/manual/manual.html">https://hydra.nixos.org/build/115931128/download/1/manual/manual.html</a>.
</div>
<div id="ref-nixopsSource" class="csl-entry" role="doc-biblioentry">
———. (2011) 2022. <em><span>NixOps</span></em>.
<span>Nix/Nixpkgs/NixOS</span>. <a
href="https://github.com/NixOS/nixops">https://github.com/NixOS/nixops</a>.
</div>
<div id="ref-openVPNDocs" class="csl-entry" role="doc-biblioentry">
OpenVPN. 2022. <span>“Community <span>Resources</span>.”</span>
<span>OpenVPN</span>. 2022. <a
href="https://openvpn.net/community-resources/">https://openvpn.net/community-resources/</a>.
</div>
<div id="ref-poetryDocs" class="csl-entry" role="doc-biblioentry">
Poetry. 2022. <span>“Introduction | <span>Documentation</span> |
<span>Poetry</span> - <span>Python</span> Dependency Management and
Packaging Made Easy.”</span> December 7, 2022. <a
href="https://python-poetry.org/docs/">https://python-poetry.org/docs/</a>.
</div>
<div id="ref-puppetDocs" class="csl-entry" role="doc-biblioentry">
Puppet. 2022. <span>“Docs | <span>Puppet</span>.”</span> 2022. <a
href="https://puppet.com/docs/">https://puppet.com/docs/</a>.
</div>
<div id="ref-ansibleDocs" class="csl-entry" role="doc-biblioentry">
Redhat. 2022. <span>“Ansible <span>Documentation</span>.”</span> 2022.
<a href="https://docs.ansible.com/">https://docs.ansible.com/</a>.
</div>
<div id="ref-mpycHome" class="csl-entry" role="doc-biblioentry">
Schoenmakers, Berry. 2022. <span>“<span>MPyC Homepage</span>.”</span>
<span>MPyC</span>. 2022. <a
href="https://win.tue.nl/~berry/mpyc">https://win.tue.nl/~berry/mpyc</a>.
</div>
<div id="ref-mpycSource" class="csl-entry" role="doc-biblioentry">
———. (2018) 2022. <em><span>MPyC</span> <span>Multiparty
Computation</span> in <span>Python</span></em>. <a
href="https://github.com/lschoe/mpyc">https://github.com/lschoe/mpyc</a>.
</div>
<div id="ref-deployrsSource" class="csl-entry" role="doc-biblioentry">
Serokell. (2020) 2022. <em>Serokell/Deploy-Rs</em>.
<span>Serokell</span>. <a
href="https://github.com/serokell/deploy-rs">https://github.com/serokell/deploy-rs</a>.
</div>
<div id="ref-shamirHowShareSecret1979" class="csl-entry"
role="doc-biblioentry">
Shamir, Adi. 1979. <span>“How to Share a Secret.”</span>
<em>Communications of the ACM</em> 22 (11): 612–13. <a
href="https://doi.org/10.1145/359168.359176">https://doi.org/10.1145/359168.359176</a>.
</div>
<div id="ref-tincDocs" class="csl-entry" role="doc-biblioentry">
Sliepen, Guus. 2022. <span>“Tinc <span>Docs</span>.”</span> November 30,
2022. <a
href="https://www.tinc-vpn.org/docs/">https://www.tinc-vpn.org/docs/</a>.
</div>
<div id="ref-didW3C" class="csl-entry" role="doc-biblioentry">
Sporny, Manu, Dave Longley, Markus Sabadello, Drummond Reed, Orie
Steele, and Christopher Allen. 2022. <span>“Decentralized
<span>Identifiers</span> (<span>DIDs</span>) V1.0.”</span> July 19,
2022. <a
href="https://www.w3.org/TR/did-core/">https://www.w3.org/TR/did-core/</a>.
</div>
<div id="ref-tailscaleDocs" class="csl-entry" role="doc-biblioentry">
Tailscale. n.d. <span>“Tailscale.”</span> <span>Tailscale</span>.
Accessed November 30, 2022. <a
href="https://tailscale.com/kb/">https://tailscale.com/kb/</a>.
</div>
<div id="ref-wikiMPC" class="csl-entry" role="doc-biblioentry">
Wikipedia. 2022. <span>“Secure Multi-Party Computation.”</span> In
<em>Wikipedia</em>. <a
href="https://en.wikipedia.org/w/index.php?title=Secure_multi-party_computation&amp;oldid=1125968812">https://en.wikipedia.org/w/index.php?title=Secure_multi-party_computation&amp;oldid=1125968812</a>.
</div>
<div id="ref-ethereumYellowPaper" class="csl-entry"
role="doc-biblioentry">
Wood, Dr Gavin. 2022. <span>“<span>ETHEREUM</span>: <span>A SECURE
DECENTRALISED GENERALISED TRANSACTION LEDGER</span>,”</span> October,
41.
</div>
<div id="ref-yaoProtocolsSecureComputations1982" class="csl-entry"
role="doc-biblioentry">
Yao, Andrew C. 1982. <span>“Protocols for Secure Computations.”</span>
In, 160–64. <span>IEEE Computer Society</span>. <a
href="https://doi.org/10.1109/SFCS.1982.88">https://doi.org/10.1109/SFCS.1982.88</a>.
</div>
</div>
